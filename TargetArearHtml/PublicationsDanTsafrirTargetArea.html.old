http://www.cs.technion.ac.il/~dan/index_pubs.html
<body>
<!-- ====================================================================== -->
<!-- the entire page is a table; 
     each row is comprised of one tr, 
     in which there's one td, 
     in which there's one table -->
<!-- ====================================================================== -->
<table border="0" cellpadding="0" cellspacing="0" class="myHomepage" style="border-collapse: collapse" width="900">
<!-- ==================== 1st line ====================== -->
<tr>
<td>
<table class="myTopTbl">
<tr>
<!-- pic (left) -->
<td><img align="left" alt="Picture of Dan" src="pics/dan-2010-white-bg-a.jpg" width="130"/></td>
<!-- text (right) -->
<td align="center" width="100%">
<!-- name -->
<a class="myName" href="http://www.cs.technion.ac.il/~dants">
		  Dan Tsafrir</a>
<br/>
<!-- Dept -->
<a class="myAffiliation" href="http://www.cs.technion.ac.il/">
		  Dept. of Computer Science</a>
<br/>
<!-- Technion -->
<a class="myAffiliation" href="http://www.technion.ac.il/en">
		  Technion - Israel Institute of Technology</a>
</td>
</tr>
</table>
</td>
</tr>
<!-- ==================== 2nd line (space) ====================== -->
<tr><td> </td></tr>
<!-- ==================== 3rd line ====================== -->
<tr>
<td>
<table border="0" cellspacing="0">
<tr>
<!-- navigation panel (left) -->
<td valign="top">
<!--
	    <table border="1" cellspacing="1" width="81" bgcolor="#008000">
	      -->
<table class="myLeftTbl">
<tr><td><a href="index.html">
		    home</a></td></tr>
<tr><td><a href="index_contact.html">
		    contact</a></td></tr>
<tr><td><a href="index_bio.html">
		    short bio</a></td></tr>
<tr><td><a href="index_committees.html">
		    service</a></td></tr>
<tr><td><a href="index_pubs.html">
		    publications</a></td></tr>
<tr><td><a href="index_students.html">
		    students</a></td></tr>
<tr><td><a href="index_courses.html">
		    courses</a></td></tr>
<!--
	      <tr><td><a href="index_collaborate.html">
		    Collaborations</a></td></tr>
	      <tr><td><a href="index_software.html">
		    Software</a></td></tr>
-->
<tr><td><a href="index_sysvenues_deadline.html">
		    systems conferences by deadline</a></td></tr>
<tr><td><a href="index_sysvenues_date.html">
		    and by date</a></td></tr>
</table>
</td>
<!-- separator (middle) -->
<td>  </td>
<!-- page body (right) -->
<td class="myBody" valign="top" width="100%">
<!-- ==== THE BODY ==== -->
<!-- ==================== 2019 ==================== -->
<!-- ==================== 2019 ==================== -->
<!-- ==================== 2019 ==================== -->
<h3>2019</h3>
<ul>
<!-- ============ dc ============ -->
<li>
<!-- anchor -->
<a name="dc"></a>
<span class="docTitle">
     Storm: a fast transactional dataplane for remote data structures
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Stanko Novakovic, Yizhou Shan, Aasheesh Kolli, Michael
         Cui, Yiying Zhang, Haggai Eran, Boris Pismenny, Liran Liss,
         Michael Wei, Dan Tsafrir, Marcos Aguilera
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">SYSTOR '19</span>: ACM International Conference on Systems and Storage
     </span>
<br/>
<!-- details -->
     June,
     2019,
     Haifa, Israel,
     <span style="background-color:#F7BDDE">awarded Best Paper</span>
<br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('dc_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('dc_bibtex');">BibTeX</a> , 
     <a href="papers/storm-systor-2019.pdf">PDF</a> , 
     <a href="https://doi.org/10.1145/3319647.3325827">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="dc_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     RDMA technology enables a host to access the memory of a remote
           host without involving the remote CPU, improving the performance
           of distributed in-memory storage systems. Previous studies
           argued that RDMA suffers from scalability issues, because the
           NIC's limited resources are unable to simultaneously cache the
           state of all the concurrent network streams.  These concerns led
           to various software-based proposals to reduce the size of this
           state by trading off performance.  We revisit these proposals
           and show that they no longer apply when using newer RDMA NICs in
           rack-scale environments.  In particular, we find that one-sided
           remote memory primitives lead to better performance as compared
           to the previously proposed unreliable datagram and kernel-based
           stacks.  Based on this observation, we design and implement
           Storm, a transactional dataplane utilizing one-sided read and
           write-based RPC primitives. We show that Storm outperforms eRPC,
           FaRM, and LITE by 3.3x, 3.6x, and 17.1x, respectively, on an
           InfiniBand cluster with Mellanox ConnectX-4 NICs.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="dc_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{novakovic19-dc,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Stanko Novakovic and Yizhou Shan and Aasheesh Kolli and Michael
         Cui and Yiying Zhang and Haggai Eran and Boris Pismenny and Liran Liss and
         Michael Wei and Dan Tsafrir and Marcos Aguilera},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Storm: a fast transactional dataplane for remote data structures},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM International Conference on Systems and Storage (SYSTOR)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2019,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {June},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Haifa, Israel}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ fbrick ============ -->
<li>
<!-- anchor -->
<a name="fbrick"></a>
<span class="docTitle">
     Apps can quickly destroy your mobile's flash: 
         why they don't, and how to keep it that way
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Tao Zhang, Aviad Zuck, Donald E. Porter, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">MobiSys '19</span>: ACM International Conference on Mobile Systems, Applications, 
         and Services
     </span>
<br/>
<!-- details -->
     June,
     2019,
     Seoul, South Korea,
     pages 207–221
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('fbrick_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('fbrick_bibtex');">BibTeX</a> , 
     <a href="papers/fbrick-mobisys-2019.pdf">PDF</a> , 
     <a href="https://doi.org/10.1145/3307334.3326108">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="fbrick_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Although flash cells wear out, a typical SSD has enough cells and
         sufficiently sophisticated firmware that its lifetime generally
         exceeds the expected lifetime of its host system. Even under heavy
         use, SSDs last for years and can be replaced upon failure. On a
         smartphone, in contrast, the hardware is more limited and we show
         that, under heavy use, one can easily, and more quickly, wear out
         smartphone flash storage. Consequently, a simple, unprivileged,
         malicious application can render a smartphone unbootable
         (“bricked”) in a few weeks with no warning signs to the user. This
         bleak result becomes more worrisome when considering the fact that
         smartphone users generally believe it is safe to try out new
         applications. To combat this problem, we study the I/O behavior of
         a wide range of Android applications. We find that high-volume
         write bursts exist, yet none of the applications we checked
         sustains an average write rate that is high enough to damage the
         device (under reasonable usage assumptions backed by the
         literature). We therefore propose a rate-limiting algorithm for
         write activity that (1) prevents such attacks, (2) accommodates
         “normal” bursts, and (3) ensures that the smartphone drive
         lifetime is longer than a preconfigured lower bound (i.e., its
         warranty). In terms of user experience, our design only requires
         that, in the worst case of an app that issues continuous,
         unsustainable, and unusual writes, the user decides whether to
         shorten the phone's life or rate limit the problematic app
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="fbrick_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{zhang19-fbrick,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Tao Zhang and Aviad Zuck and Donald E. Porter and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Apps can quickly destroy your mobile's flash: 
         why they don't, and how to keep it that way},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM International Conference on Mobile Systems, Applications, 
         and Services (MobiSys)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2019,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {June},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {207--221},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Seoul, South Korea}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ frvrs ============ -->
<li>
<!-- anchor -->
<a name="frvrs"></a>
<span class="docTitle">
     Why and how to increase SSD performance transparency
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Aviad Zuck, Tao Zhang, Philipp Guhring, Donald E. Porter, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">HotOS '19</span>: ACM Workshop on Hot Topics in Operating Systems
     </span>
<br/>
<!-- details -->
     May,
     2019,
     Bertinoro, Italy,
     pages 192–200
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('frvrs_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('frvrs_bibtex');">BibTeX</a> , 
     <a href="papers/frvrs-hotos-2019.pdf">PDF</a> , 
     <a href="https://doi.org/10.1145/3317550.3321430">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="frvrs_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Even on modern SSDs, I/O scheduling is a first-order performance
         concern. However, it is unclear how best to optimize I/O patterns
         for SSDs, because a complex layer of proprietary firmware hides
         many principal aspects of performance, as well as SSD
         lifetime. Losing this information leads to research papers drawing
         incorrect conclusions about prototype systems, as well as
         real-world systems realizing sub-optimal performance and
         lifetime. It is our position that a useful performance model of a
         foundational system component is essential, and the community
         should support efforts to construct models of SSD performance. We
         show examples from the literature and our own measurements that
         illustrate serious limitations of current SSD modeling tools and
         disk statistics. We observe an opportunity to resolve this problem
         by reverse engineering SSDs, leveraging recent trends toward
         component standardization within SSDs. This paper presents a
         feasibility study and initial results to reverse engineer a
         commercial SSD's firmware, and discusses limitations and open
         problems.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="frvrs_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{zuck19-frvrs,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Aviad Zuck and Tao Zhang and Philipp Guhring and Donald E. Porter and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Why and how to increase {SSD} performance transparency},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM Workshop on Hot Topics in Operating Systems (HotOS)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2019,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {May},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {192--200},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Bertinoro, Italy}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
</ul>
<!-- ==================== 2018 ==================== -->
<!-- ==================== 2018 ==================== -->
<!-- ==================== 2018 ==================== -->
<h3>2018</h3>
<ul>
<!-- ============ damn ============ -->
<li>
<!-- anchor -->
<a name="damn"></a>
<span class="docTitle">
     DAMN: overhead-free IOMMU protection for networking
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Alex Markuze, Igor Smolyar, Adam Morrison, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">ASPLOS '18</span>: ACM International Conference on Architectural Support for
       Languages and Operating Systems
     </span>
<br/>
<!-- details -->
     March,
     2018,
     Williamsburg, VA,
     pages 301–315
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('damn_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('damn_bibtex');">BibTeX</a> , 
     <a href="papers/damn-asplos-2018.pdf">PDF</a> , 
     <a href="https://doi.org/10.1145/3173162.3173175">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="damn_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     DMA operations can access memory buffers only if they are
         “mapped” in the IOMMU, so operating systems protect themselves
         against malicious/errant network DMAs by mapping and unmapping
         each packet immediately before/after it is DMAed. This approach
         was recently found to be riskier and less performant than keeping
         packets non-DMAable and instead copying their content to/from
         permanently-mapped buffers. Still, the extra copy hampers
         performance of multi-gigabit networking.
     
     <br/><br/>
     
         We observe that achieving protection at the DMA (un)map boundary
         is needlessly constraining, as devices must be prevented from
         changing the data only after the kernel reads it. So there is no
         real need to switch ownership of buffers between kernel and device
         at the DMA (un)mapping layer, as opposed to the approach taken by
         all existing IOMMU protection schemes. We thus eliminate the extra
         copy by (1) implementing a new allocator called DMA-Aware Malloc
         for Networking (DAMN), which (de)allocates packet buffers from a
         memory pool permanently mapped in the IOMMU; (2) modifying the
         network stack to use this allocator; and (3) copying packet data
         only when the kernel needs it, which usually morphs the
         aforementioned extra copy into the kernel's standard copy
         operation performed at the user-kernel boundary. DAMN thus
         provides full IOMMU protection with performance comparable to that
         of an unprotected system.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="damn_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{markuze18-damn,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Alex Markuze and Igor Smolyar and Adam Morrison and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {{DAMN}: overhead-free {IOMMU} protection for networking},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM International Conference on Architectural Support for
       Languages and Operating Systems (ASPLOS)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2018,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {March},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {301--315},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Williamsburg, VA}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ flashdeny ============ -->
<li>
<!-- anchor -->
<a name="flashdeny"></a>
<span class="docTitle">
     Stash in a flash
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Aviad Zuck, Yue Li, Jehoshua Bruck, Donald E. Porter, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">FAST '18</span>: USENIX Conference on File and Storage Technologies
     </span>
<br/>
<!-- details -->
     February,
     2018,
     Oakland CA,
     pages 169–188
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('flashdeny_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('flashdeny_bibtex');">BibTeX</a> , 
     <a href="papers/stash-fast-2018.pdf">PDF</a> , 
     <a href="https://www.usenix.org/conference/fast18/presentation/zuck">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="flashdeny_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Encryption is a useful tool to protect data confidentiality. Yet
         it is still challenging to hide the very presence of encrypted,
         secret data from a powerful adversary. This paper presents a new
         technique to hide data in flash by manipulating the voltage level
         of pseudo-randomlyselected flash cells to encode two bits (rather
         than one) in the cell. In this model, we have one “public” bit
         interpreted using an SLC-style encoding, and extract a private bit
         using an MLC-style encoding. The locations of cells that encode
         hidden data is based on a secret key known only to the hiding
         user.
     
     <br/><br/>
     
         Intuitively, this technique requires that the voltage level in a
         cell encoding data must be (1) not statistically distinguishable
         from a cell only storing public data, and (2) the user must be
         able to reliably read the hidden data from this cell. Our key
         insight is that there is a wide enough variation in the range of
         voltage levels in a typical flash device to obscure the presence
         of fine-grained changes to a small fraction of the cells, and that
         the variation is wide enough to support reliably re-reading hidden
         data. We demonstrate that our hidden data and underlying voltage
         manipulations go undetected by support vector machine based
         supervised learning which performs similarly to a random guess.
         The error rates of our scheme are low enough that the data is
         recoverable months after being stored. Compared to prior work, our
         technique provides 24x and 50x higher encoding and decoding
         throughput and doubles the capacity, while being 37x more power
         efficient.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="flashdeny_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{zuck18-flashdeny,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Aviad Zuck and Yue Li and Jehoshua Bruck and Donald E. Porter and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Stash in a flash},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {USENIX Conference on File and Storage Technologies (FAST)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2018,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {February},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {169--188},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Oakland CA}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
</ul>
<!-- ==================== 2017 ==================== -->
<!-- ==================== 2017 ==================== -->
<!-- ==================== 2017 ==================== -->
<h3>2017</h3>
<ul>
<!-- ============ everchng ============ -->
<li>
<!-- anchor -->
<a name="everchng"></a>
<span class="docTitle">
     Preserving hidden data with an ever-changing disk
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Aviad Zuck, Udi Shriki, Donald E. Porter, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">HotOS '17</span>: ACM Workshop on Hot Topics in Operating Systems
     </span>
<br/>
<!-- details -->
     May,
     2017,
     Whistler, Canada,
     pages 50–55
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('everchng_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('everchng_bibtex');">BibTeX</a> , 
     <a href="papers/everchange-hotos-2017.pdf">PDF</a> , 
     <a href="https://doi.org/10.1145/3102980.3102989">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="everchng_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     This paper presents a storage system that can hide the presence of
        hidden data alongside a larger volume of public data.  Encryption
        allows a user to hide the contents of data, but not the fact that
        sensitive data is present. Under duress, the owner of high-value
        data can be coerced by a powerful adversary to disclose decryption
        keys. Thus, private users and corporations have an interest in
        hiding the very presence of some sensitive data, alongside a larger
        body of less sensitive data (e.g., the operating system and other
        benign files); this property is called plausible
        deniability. Existing plausible deniability systems do not fulfill
        all of the following requirements: (1) resistance to multiple
        snapshot attacks where an attacker compares the state of the device
        over time; (2) ensuring that hidden data won't be destroyed when
        the public volume is modified by a user unaware of the hidden data;
        and (3) disguising writes to secret data as normal system
        operations on public data.
     
     <br/><br/>
     
        We explain why existing solutions do not meet all these
        requirements and present the Ever-Changing Disk (ECD), a generic
        scheme for plausible deniability storage systems that meets all of
        these requirements. An ECD stores hidden data inside a large volume
        of pseudorandom data. Portions of this volume are periodically
        migrated in a log-structured manner.  Hidden writes can then be
        interchanged with normal firmware operations. The expected access
        patterns and time until hidden data is overwritten are completely
        predictable, and insensitive to whether data is hidden. Users
        control the rate of internal data migration (R), trading write
        bandwidth to hidden data for longevity of the hidden data. For a
        typical 2TB disk and setting of R, a user preserves hidden data by
        entering her secret key every few days or weeks.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="everchng_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{zuck17-everchng,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Aviad Zuck and Udi Shriki and Donald E. Porter and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Preserving hidden data with an ever-changing disk},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM Workshop on Hot Topics in Operating Systems (HotOS)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2017,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {May},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {50--55},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Whistler, Canada}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ fbrick ============ -->
<li>
<!-- anchor -->
<a name="fbrick"></a>
<span class="docTitle">
     Flash drive lifespan *is* a problem
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Tao Zhang, Aviad Zuck, Donald E. Porter, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">HotOS '17</span>: ACM Workshop on Hot Topics in Operating Systems
     </span>
<br/>
<!-- details -->
     May,
     2017,
     Whistler, Canada,
     pages 42–49
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('fbrick_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('fbrick_bibtex');">BibTeX</a> , 
     <a href="papers/fbrick-hotos-2017.pdf">PDF</a> , 
     <a href="https://doi.org/10.1145/3102980.3102988">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="fbrick_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     When flash was introduced, wear-out was a known problem. Over
         time, a number of techniques have been developed to estimate the
         expected number of program/erase cycles under typical usage
         patterns, and sufficiently over-provision the cells such that the
         device meets its expected lifespan, even if individual cells fail.
         This paper started as a simple experiment: measuring whether the
         lifespan of flash devices in smartphones and other mobile devices,
         match the estimates. To our surprise, we find that, in a matter of
         days, simple, unprivileged applications can render the drive of
         several smartphones (and thus, the phone) inoperable. This result
         is concerning, as it means that installing malicious or
         poorly-written software could destroy the device itself. We
         experimentally demonstrate the problem, discuss reasons why it
         occurs, and consider potential solutions.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="fbrick_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{zhang17-fbrick,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Tao Zhang and Aviad Zuck and Donald E. Porter and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Flash drive lifespan *is* a problem},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM Workshop on Hot Topics in Operating Systems (HotOS)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2017,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {May},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {42--49},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Whistler, Canada}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ npf ============ -->
<li>
<!-- anchor -->
<a name="npf"></a>
<span class="docTitle">
     Page fault support for network controllers
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Ilya Lesokhin, Haggai Eran, Shachar Raindel, Guy Shapiro,
                   Sagi Grimberg, Liran Liss, Muli Ben-Yehuda, Nadav Amit,
                   Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">ASPLOS '17</span>: ACM International Conference on Architectural Support for
           Programming Languages and Operating Systems
     </span>
<br/>
<!-- details -->
     April,
     2017,
     Xi'an, China,
     pages 449–466,
     to appear
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('npf_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('npf_bibtex');">BibTeX</a> , 
     <a href="papers/npf-asplos-2017.pdf">PDF</a> , 
     <a href="https://doi.org/10.1145/3093337.3037710">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="npf_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Direct network I/O allows network controllers (NICs) to expose
        multiple instances of themselves, to be used by untrusted software
        without a trusted intermediary. Direct I/O thus frees researchers
        from legacy software, fueling studies that innovate in multitenant
        setups.  Such studies, however, overwhelmingly ignore one serious
        problem: direct memory accesses (DMAs) of NICs disallow page
        faults, forcing systems to either pin entire address spaces to
        physical memory and thereby hinder memory utilization, or resort to
        APIs that pin/unpin memory buffers before/after they are DMAed,
        which complicates the programming model and hampers performance.
     
     <br/><br/>
     
        We solve this problem by designing and implementing page fault
        support for InfiniBand and Ethernet NICs. A main challenge we
        tackle—unique to NICs—is handling receive DMAs that trigger
        page faults, leaving the NIC without memory to store the incoming
        data. We demonstrate that our solution provides all the benefits
        associated with “regular” virtual memory, notably (1) a simpler
        programming model that rids users from the need to pin, and (2) the
        ability to employ all the canonical memory optimizations, such as
        memory overcommitment and demand-paging based on actual use. We
        show that, as a result, benchmark performance improves by up to
        1.9x.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="npf_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{lesokhin17-npf,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Ilya Lesokhin and Haggai Eran and Shachar Raindel and Guy Shapiro and
                   Sagi Grimberg and Liran Liss and Muli Ben-Yehuda and Nadav Amit and
                   Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Page fault support for network controllers},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM International Conference on Architectural Support for
           Programming Languages and Operating Systems (ASPLOS)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2017,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {April},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {449--466},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Xi'an, China},</td>
</tr>
<tr>
<td align="right" valign="top">note</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {(to appear)}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ virtbook ============ -->
<li>
<!-- anchor -->
<a name="virtbook"></a>
<span class="docTitle">
     Hardware and software support for virtualization
     </span>
       [<span style="background-color:#F7BDDE">book</span>]
     <br/>
<!-- author -->
<span class="docAuthors">
     Edouard Bugnion, Jason Nieh, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">Morgan &amp; Claypool</span> Publishers
     </span>
<br/>
<!-- details -->
     Synthesis Lectures on Computer Architecture,
     February,
     2017,
     pages 1–206,
     volume 12,
     number 1
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('virtbook_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('virtbook_bibtex');">BibTeX</a> , 
     <a href="https://doi.org/10.2200/S00754ED1V01Y201701CAC038">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="virtbook_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     This textbook focuses on the core question of the necessary
       architectural support provided by hardware to efficiently run
       virtual machines, and of the corresponding design of the hypervisors
       that run them.  Virtualization is still possible when the
       instruction set architecture lacks such support, but the hypervisor
       remains more complex and must rely on additional techniques.
     
     <br/><br/>
     
       Despite the focus on architectural support in current architectures,
       some historical perspective is necessary to appropriately frame the
       problem.  The first half of the text provides the historical
       perspective of the theoretical framework developed four decades ago
       by Popek and Goldberg. It also describes earlier systems that
       enabled virtualization despite the lack of architectural support in
       hardware.
     
     <br/><br/>
     
       As is often the case, theory defines a necessary—but not
       sufficient—set of features, and modern architectures are the
       result of the combination of the theoretical framework with insights
       derived from practical systems.  The second half of the text
       describes state-of-the-art support for virtualization in both x86-64
       and ARM processors.  This textbook includes an in-depth description
       of the CPU, memory and I/O virtualization of these two processor
       architectures, as well as case studies on the Linux/KVM, VMware, and
       Xen hypervisors.  It concludes with a performance comparison of
       virtualization on current-generation x86- and ARM-based systems
       across multiple hypervisors.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="virtbook_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @Book{bugnion17-virtbook,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Edouard Bugnion and Jason Nieh and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Hardware and software support for virtualization},</td>
</tr>
<tr>
<td align="right" valign="top">publisher</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Morgan &amp; Claypool Publishers},</td>
</tr>
<tr>
<td align="right" valign="top">series</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Synthesis Lectures on Computer Architecture},</td>
</tr>
<tr>
<td align="right" valign="top">volume</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       12,</td>
</tr>
<tr>
<td align="right" valign="top">number</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       1,</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2017,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {February},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {1--206}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
</ul>
<!-- ==================== 2016 ==================== -->
<!-- ==================== 2016 ==================== -->
<!-- ==================== 2016 ==================== -->
<h3>2016</h3>
<ul>
<!-- ============ hvsr ============ -->
<li>
<!-- anchor -->
<a name="hvsr"></a>
<span class="docTitle">
     Hash, don't cache (the page table)
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Idan Yaniv, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">SIGMETRICS '16</span>: ACM SIGMETRICS International Conference on Measurement and
         Modeling
     </span>
<br/>
<!-- details -->
     June,
     2016,
     Antibes Juan-les-Pins, France,
     pages 337–350
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('hvsr_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('hvsr_bibtex');">BibTeX</a> , 
     <a href="papers/hvsr-sigmetrics-2016.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1145/2896377.2901456">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="hvsr_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Radix page tables as implemented in the x86-64 architecture incur
         a penalty of four memory references for address translation upon
         each TLB miss. These 4 references become 24 in virtualized setups,
         accounting for 5%–90% of the runtime and thus motivating chip
         vendors to incorporate page walk caches
         (PWCs). Counterintuitively, an ISCA'10 paper found that radix page
         tables with PWCs are superior to hashed page tables, yielding up
         to 5x fewer DRAM accesses per page walk. We challenge this finding
         and show that it is the result of comparing against a suboptimal
         hashed implementation—that of the Itanium architecture. We show
         that, when carefully optimized, hashed page tables in fact
         outperform existing PWC-aided x86-64 hardware, shortening
         benchmark runtimes by 1%–27% and 6%–32% in bare-metal and
         virtualized setups, without resorting to PWCs. We further show
         that hashed page tables are inherently more scalable than radix
         designs and are better suited to accommodate the ever increasing
         memory size; their downside is that they make it more challenging
         to support such features as superpages.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="hvsr_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{yaniv16-hvsr,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Idan Yaniv and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Hash, don't cache (the page table)},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM SIGMETRICS International Conference on Measurement and
         Modeling (SIGMETRICS)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2016,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {June},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {337--350},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Antibes Juan-les-Pins, France}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ waci ============ -->
<li>
<!-- anchor -->
<a name="waci"></a>
<span class="docTitle">
     Synopsis of the ASPLOS '16 wild and crazy ideas (WACI) invited-speakers session
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">ASPLOS '16</span>: ACM International Conference on Architectural Support for
           Programming Languages and Operating Systems
     </span>
<br/>
<!-- details -->
     April,
     2016,
     Atlanta, GA,
     pages 291–294
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('waci_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('waci_bibtex');">BibTeX</a> , 
     <a href="papers/waci-asplos-2016.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1145/2872362.2876512">Definitive</a> , 
     <a href="https://www.ece.cmu.edu/calcm/asplos2016/waci.html">Webpage</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="waci_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     The Wild and Crazy Ideas (WACI) session is a longstanding tradition
        at ASPLOS, soliciting talks that consist of forward-looking,
        visionary, inspiring, creative, far out or just plain amazing ideas
        presented in an exciting way. (Amusing elements in the
        presentations are tolerated ;-) but are in fact optional.)
     
     <br/><br/>
     
        The first WACI session took place in 1998. Back then, the call for
        talks included a problem statement, which contended that “papers
        usually do not get admitted to [such conferences as] ISCA or ASPLOS
        unless the systems that they describe are mature enough to run
        [some standard benchmark suites, which] has a chilling effect on
        the idea generation process—encouraging incremental research”
        [1]. The 1998 WACI session turned out to be a great success. Its
        webpage states that ”there were 42 submissions [competing over]
        only eight time slots, [which resulted in] this session [having] a
        lower acceptance rate than the conference itself” [2].
     
     <br/><br/>
     
        But the times they are a-changin' [3], and the WACI session no
        longer enjoys that many submissions (Figure 1), perhaps because
        nowadays there exist many forums for researchers to
        describe/discuss their preliminary ideas, including: the “hot
        topics in” workshops [4–7]; a journal like CAL, dedicated to
        early results [8]; main conferences soliciting short submissions
        describing “original or unconventional ideas at a preliminary
        stage” in addition to regular papers [9]; and the many workshops
        co-located with main conferences, like ISCA '15, which hosted
        thirteen such workshops [10].
     
     <br/><br/>
     
        Regardless of the reason for the declining number of submissions,
        this time we've decided to organize the WACI session differently to
        ensure its continued high quality. Instead of soliciting talks via
        an open call and hoping for the best, we proactively invited
        speakers whom we believe are capable of delivering excellent WACI
        presentations. That is, this year's WACI session consists
        exclusively of invited speakers. Filling up the available slots
        turned out to be fairly easy, as most of the researchers we invited
        promptly accepted our invitation. The duration of each talk was set
        to be eight minutes (exactly as in the first WACI session from
        1998) plus two minutes for questions.
     
     <br/><br/>
     
        The talks are outlined below. We believe they are interesting and
        exciting, and we hope the attendees of the session will find them
        stimulating and insightful.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="waci_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{tsafrir16-waci,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Synopsis of the {ASPLOS} '16 wild and crazy ideas {(WACI)} invited-speakers session},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM International Conference on Architectural Support for
           Programming Languages and Operating Systems (ASPLOS)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2016,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {April},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {291--294},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Atlanta, GA}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ vrio ============ -->
<li>
<!-- anchor -->
<a name="vrio"></a>
<span class="docTitle">
     vRIO: Paravirtual remote I/O
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Yossi Kuperman, Eyal Moscovici, Joel Nider,
               Razya Ladelsky, Abel Gordon, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">ASPLOS '16</span>: ACM International Conference on Architectural Support for
           Programming Languages and Operating Systems
     </span>
<br/>
<!-- details -->
     April,
     2016,
     Atlanta, GA,
     pages 49–65
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('vrio_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('vrio_bibtex');">BibTeX</a> , 
     <a href="papers/vrio-asplos-2016.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1145/2872362.2872378">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="vrio_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     The traditional “trap and emulate” I/O paravirtualization model
         conveniently allows for I/O interposition, yet it inherently
         incurs costly guest-host context switches. The newer “sidecore”
         model eliminates this overhead by dedicating host (side)cores to
         poll the relevant guest memory regions and react accordingly
         without context switching. But the dedication of sidecores on each
         host might be wasteful when I/O activity is low, or it might not
         provide enough computational power when I/O activity is high. We
         propose to alleviate this problem at rack scale by consolidating
         the dedicated sidecores spread across several hosts onto one
         server. The hypervisor is then effectively split into two parts:
         the local hypervisor that hosts the VMs, and the remote hypervisor
         that processes their paravirtual I/O.  We call this model
         vRIO—paraVirtual Remote I/O. We find that by increasing the
         latency somewhat, it provides comparable throughput with fewer
         sidecores and superior throughput with the same number of
         sidecores as compared to the state of the art. vRIO additionally
         constitutes a new, cost-effective way to consolidate I/O devices
         (on the remote hypervisor) while supporting efficient programmable
         I/O interposition.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="vrio_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{kuperman16-vrio,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Yossi Kuperman and Eyal Moscovici and Joel Nider and
               Razya Ladelsky and Abel Gordon and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {{vRIO}: {Paravirtual} remote {I/O}},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM International Conference on Architectural Support for
           Programming Languages and Operating Systems (ASPLOS)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2016,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {April},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {49--65},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Atlanta, GA}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ cim ============ -->
<li>
<!-- anchor -->
<a name="cim"></a>
<span class="docTitle">
     True IOMMU protection from DMA attacks: when copy is faster than zero copy
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Alex Markuze, Adam Morrison, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">ASPLOS '16</span>: ACM International Conference on Architectural Support for
           Programming Languages and Operating Systems
     </span>
<br/>
<!-- details -->
     April,
     2016,
     Atlanta, GA,
     pages 249–262
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('cim_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('cim_bibtex');">BibTeX</a> , 
     <a href="papers/cim-asplos-2016.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1145/2872362.2872379">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="cim_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Malicious I/O devices might compromise the OS using DMAs. The OS
        therefore utilizes the IOMMU to map and unmap every target buffer
        right before and after its DMA is processed, thereby restricting
        DMAs to their designated locations. This usage model, however, is
        not truly secure for two reasons: (1) it provides protection at
        page granularity only, whereas DMA buffers can reside on the same
        page as other data; and (2) it delays DMA buffer unmaps due to
        performance considerations, creating a vulnerability window in
        which devices can access in-use memory.
     
     <br/><br/>
     
        We propose that OSes utilize the IOMMU differently, in a manner
        that eliminates these two flaws.  Our new usage model restricts
        device access to a set of shadow DMA buffers that are never
        unmapped, and it copies DMAed data to/from these buffers, thus
        providing sub-page protection while eliminating the aforementioned
        vulnerability window. Our key insight is that the cost of
        interacting with, and synchronizing access to the slow IOMMU
        hardware—required for zero-copy protection against devices—make
        {\em copying preferable to zero-copying}.
     
     <br/><br/>
     
        We implement our model in Linux and evaluate it with standard
        networking benchmarks utilizing a 40\,Gb/s NIC. We demonstrate that
        despite being more secure than the safest preexisting usage model,
        our approach provides up to 5<i>\times</i> higher
        throughput. Additionally, whereas it is inherently less scalable
        than an IOMMU-less (unprotected) system, our approach incurs only
        0%–25% performance degradation in comparison.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="cim_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{markuze16-cim,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Alex Markuze and Adam Morrison and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {True {IOMMU} protection from {DMA} attacks: when copy is faster than zero copy},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM International Conference on Architectural Support for
           Programming Languages and Operating Systems (ASPLOS)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2016,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {April},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {249--262},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Atlanta, GA}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ nom ============ -->
<li>
<!-- anchor -->
<a name="nom"></a>
<span class="docTitle">
     The nom profit-maximizing operating system
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Muli Ben-Yehuda, Orna Agmon Ben-Yehuda, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">VEE '16</span>: ACM SIGPLAN/SIGOPS International Conference on
           Virtual Execution Environments
     </span>
<br/>
<!-- details -->
     April,
     2016,
     Atlanta, GA,
     pages 145–160
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('nom_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('nom_bibtex');">BibTeX</a> , 
     <a href="papers/nom-vee-2016.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1145/2892242.2892250">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="nom_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     In the near future, cloud providers will sell their users virtual
         machines with CPU, memory, network, and storage resources whose
         prices constantly change according to market-driven supply and
         demand conditions. Running traditional operating systems in these
         virtual machines is a poor fit: traditional operating systems are
         not aware of changing resource prices and their sole aim is to
         maximize performance with no consideration of costs. Consequently,
         they yield low profits.
     
     <br/><br/>
     
         We present nom, a profit-maximizing operating system designed for
         cloud computing platforms with dynamic resource
         prices. Applications running on nom aim to maximize profits by
         optimizing simultaneously for performance and resource costs. The
         nom kernel provides them with direct access to the underlying
         hardware and full control over their private software
         stacks. Since nom applications know there is no single “best”
         software stack, they adapt their stacks' behavior on the fly
         according to the current price of available resources and their
         private utility from them, which differs between applications. We
         show that in addition to achieving up to 3.9x better throughput
         and up to 9.1x better latency, nom applications yield up to 11.1x
         higher profits when compared with the same applications running on
         Linux and OSv.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="nom_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{ben-yehuda16-nom,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Muli Ben-Yehuda and Orna {Agmon Ben-Yehuda} and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {The nom profit-maximizing operating system},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM SIGPLAN/SIGOPS International Conference on
           Virtual Execution Environments (VEE)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2016,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {April},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {145--160},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Atlanta, GA}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ elij ============ -->
<li>
<!-- anchor -->
<a name="elij"></a>
<span class="docTitle">
     Bare-metal performance for virtual machines with exitless 
         interrupts
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Nadav Amit, Abel Gordon, Nadav Har'El, Muli Ben-Yehuda,
         Alex Landau, Assaf Schuster, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">CACM</span>: Communications of the ACM
     </span>
<br/>
<!-- details -->
     January,
     2016,
     pages 108–116,
     volume 59,
     number 1,
     <span style="background-color:#F7BDDE"><a href="http://www.sigarch.org/awards/cacm-research-highlights/">CACM Research Highlight</a></span>
<br/>
     (See <span style="background-color:#F7BDDE"><a href="http://dx.doi.org/10.1145/2845910">technical perspective</a></span> by Steven Hand.)
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('elij_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('elij_bibtex');">BibTeX</a> , 
     <a href="papers/eli-cacm-2016.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1145/2845648">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="elij_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Direct device assignment enhances the performance of guest virtual
         machines by allowing them to communicate with I/O devices without
         host involvement. But even with device assignment, guests are
         still unable to approach bare-metal performance, because the host
         intercepts all interrupts, including those generated by assigned
         devices to signal to guests the completion of their I/O
         requests. The host involvement induces multiple unwarranted
         guest/host context switches, which significantly hamper the
         performance of I/O intensive workloads. To solve this problem, we
         present ExitLess Interrupts (ELI), a software-only approach for
         handling interrupts within guest virtual machines directly and
         securely. By removing the host from the interrupt handling path,
         ELI improves the throughput and latency of unmodified, untrusted
         guests by 1.3x–1.6x, allowing them to reach 97%–100% of
         bare-metal performance even for the most demanding I/O-intensive
         workloads.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="elij_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @Article{amit16-elij,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Nadav Amit and Abel Gordon and Nadav Har'El and Muli Ben-Yehuda and
         Alex Landau and Assaf Schuster and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Bare-metal performance for virtual machines with exitless 
         interrupts},</td>
</tr>
<tr>
<td align="right" valign="top">journal</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Communications of the ACM (CACM)},</td>
</tr>
<tr>
<td align="right" valign="top">volume</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       59,</td>
</tr>
<tr>
<td align="right" valign="top">number</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       1,</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2016,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {January},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {108--116}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
</ul>
<!-- ==================== 2015 ==================== -->
<!-- ==================== 2015 ==================== -->
<!-- ==================== 2015 ==================== -->
<h3>2015</h3>
<ul>
<!-- ============ hvfuz ============ -->
<li>
<!-- anchor -->
<a name="hvfuz"></a>
<span class="docTitle">
     Virtual CPU validation
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Nadav Amit, Dan Tsafrir, Assaf Schuster, Ahmad Ayoub, Eran Shlomo
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">SOSP '15</span>: ACM Symposium on Operating Systems Principles
     </span>
<br/>
<!-- details -->
     October,
     2015,
     Monterey, CA,
     pages 311–327
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('hvfuz_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('hvfuz_bibtex');">BibTeX</a> , 
     <a href="papers/vcpu-sosp-2015.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1145/2815400.2815420">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="hvfuz_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Testing the hypervisor is important for ensuring the correct
           operation and security of systems, but it is a hard and
           challenging task. We observe, however, that the challenge is
           similar in many respects to that of testing real CPUs. We thus
           propose to apply the testing environment of CPU vendors to
           hypervisors. We demonstrate the advantages of our proposal by
           adapting Intel's testing facility to the Linux KVM
           hypervisor. We uncover and fix 117 bugs, six of which are
           security vulnerabilities. We further find four flaws in Intel
           virtualization technology, causing a disparity between the
           observable behavior of code running on virtual and bare-metal
           servers.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="hvfuz_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{amit15-hvfuz,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Nadav Amit and Dan Tsafrir and Assaf Schuster and Ahmad Ayoub and Eran Shlomo},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Virtual {CPU} validation},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM Symposium on Operating Systems Principles (SOSP)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2015,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {October},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {311--327},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Monterey, CA}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ sriovsec ============ -->
<li>
<!-- anchor -->
<a name="sriovsec"></a>
<span class="docTitle">
     Securing self-virtualizing Ethernet devices
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Igor Smolyar, Muli Ben-Yehuda, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">USENIX Security</span> Symposium
     </span>
<br/>
<!-- details -->
     August,
     2015,
     Washington, D.C.,
     pages 335–350
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('sriovsec_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('sriovsec_bibtex');">BibTeX</a> , 
     <a href="papers/sriovsec-usenixsec-2015.pdf">PDF</a> , 
     <a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/smolyar">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="sriovsec_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Single root I/O virtualization (SRIOV) is a hardware/software
           interface that allows devices to “self virtualize” and thereby
           remove the host from the critical I/O path. SRIOV thus brings
           near bare-metal performance to untrusted guest virtual machines
           (VMs) in public clouds, enterprise data centers, and
           high-performance computing setups. We identify a design flaw in
           current Ethernet SRIOV NIC deployments that enables untrusted
           VMs to completely control the throughput and latency of other,
           unrelated VMs. The attack exploits Ethernet “pause” frames,
           which enable network flow control functionality. We
           experimentally launch the attack across several NIC models and
           find that it is effective and highly accurate, with substantial
           consequences if left unmitigated: (1) to be safe, NIC vendors
           will have to modify their NICs so as to filter pause frames
           originating from SRIOV instances; (2) in the meantime,
           administrators will have to either trust their VMs, or configure
           their switches to ignore pause frames, thus relinquishing flow
           control, which might severely degrade networking performance. We
           present the Virtualization-Aware Network Flow Controller
           (VANFC), a software-based SRIOV NIC prototype that overcomes the
           attack. VANFC filters pause frames from malicious virtual
           machines without any loss of performance, while keeping SRIOV
           and Ethernet flow control hardware/software interfaces intact.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="sriovsec_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{smolyar15-sriovsec,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Igor Smolyar and Muli Ben-Yehuda and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Securing self-virtualizing {Ethernet} devices},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {USENIX Security Symposium},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2015,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {August},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {335--350},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Washington, D.C.}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ eskimo ============ -->
<li>
<!-- anchor -->
<a name="eskimo"></a>
<span class="docTitle">
     Utilizing the IOMMU scalably
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Omer Peleg, Adam Morrison, Benjamin Serebrin, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">ATC '15</span>: USENIX Annual Technical Conference
     </span>
<br/>
<!-- details -->
     July,
     2015,
     Santa Clara, CA,
     pages 549–562
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('eskimo_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('eskimo_bibtex');">BibTeX</a> , 
     <a href="papers/eskimo-atc-2015.pdf">PDF</a> , 
     <a href="https://www.usenix.org/conference/atc15/technical-session/presentation/peleg">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="eskimo_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     IOMMUs provided by modern hardware allow the OS to enforce
             memory protection controls on the DMA operations of its I/O
             devices. An IOMMU translation management design must scalably
             handle frequent concurrent updates of IOMMU translations made
             by multiple cores, which occur in high throughput I/O
             workloads such as multi-Gb/s networking. Today, however, OSes
             experience performance meltdowns when using the IOMMU in such
             workloads.
     
     <br/><br/>
     
             This paper explores scalable IOMMU management designs and
             addresses the two main bottlenecks we find in current OSes:
             (1) assignment of I/O virtual addresses (IOVAs), and
             (2) management of the IOMMU's TLB.
     
     <br/><br/>
     
             We propose three approaches for scalable IOVA assignment:
             (1) dynamic identity mappings, which eschew IOVA allocation
             altogether, (2) allocating IOVAs using the kernel's kmalloc,
             and (3) per-core caching of IOVAs allocated by a
             globally-locked IOVA allocator. We further describe a scalable
             IOMMU TLB management scheme that is compatible with all these
             approaches.
     
     <br/><br/>
     
             Evaluation of our designs under Linux shows that (1) they
             achieve 88.5%–100% of the performance obtained without an
             IOMMU, (2) they achieve similar latency to that obtained
             without an IOMMU, (3) scalable IOVA allocation and dynamic
             identity mappings perform comparably, and (4) kmalloc provides
             a simple solution with high performance, but can suffer from
             unbounded page table blowup.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="eskimo_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{peleg15-eskimo,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Omer Peleg and Adam Morrison and Benjamin Serebrin and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Utilizing the {IOMMU} scalably},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {USENIX Annual Technical Conference (ATC)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2015,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {July},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {549--562},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Santa Clara, CA}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ riommu ============ -->
<li>
<!-- anchor -->
<a name="riommu"></a>
<span class="docTitle">
     rIOMMU: Efficient IOMMU for I/O devices that employ ring
           buffers
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Moshe Malka, Nadav Amit, Muli Ben-Yehuda, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">ASPLOS '15</span>: ACM International Conference on Architectural Support for
           Programming Languages and Operating Systems
     </span>
<br/>
<!-- details -->
     March,
     2015,
     Istanbul, Turkey,
     pages 355–368
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('riommu_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('riommu_bibtex');">BibTeX</a> , 
     <a href="papers/riommu-asplos-2015.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1145/2694344.2694355">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="riommu_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     The IOMMU allows the OS to encapsulate I/O devices in their own
         virtual memory spaces, thus restricting their DMAs to specific
         memory pages. The OS uses the IOMMU to protect itself against
         buggy drivers and malicious/errant devices. But the added
         protection comes at a cost, degrading the throughput of
         I/O-intensive workloads by up to an order of magnitude. This cost
         has motivated system designers to trade off some safety for
         performance, e.g., by leaving stale information in the IOTLB for a
         while so as to amortize costly invalidations.
     
     <br/><br/>
     
         We observe that high-bandwidth devices—like network and PCIe SSD
         controllers—interact with the OS via circular ring buffers that
         that induce a sequential, predictable workload. We design a ring
         IOMMU (rIOMMU) that leverages this characteristic by replacing the
         virtual memory page table hierarchy with a circular, flat table. A
         flat table is adequately supported by exactly one IOTLB entry,
         making every new translation an implicit invalidation of the
         former and thus requiring explicit invalidations only at the end
         of I/O bursts. Using standard networking benchmarks, we show that
         rIOMMU provides up to 7.56x higher throughput relative to the
         baseline IOMMU, and that it is within 0.77–1.00x the throughput
         of a system without IOMMU protection.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="riommu_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{malka15-riommu,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Moshe Malka and Nadav Amit and Muli Ben-Yehuda and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {{rIOMMU}: {Efficient} {IOMMU} for {I/O} devices that employ ring
           buffers},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM International Conference on Architectural Support for
           Programming Languages and Operating Systems (ASPLOS)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2015,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {March},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {355--368},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Istanbul, Turkey}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ eiovar ============ -->
<li>
<!-- anchor -->
<a name="eiovar"></a>
<span class="docTitle">
     Efficient intra-operating system protection against harmful DMAs
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Moshe Malka, Nadav Amit, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">FAST '15</span>: USENIX Conference on File and Storage Technologies
     </span>
<br/>
<!-- details -->
     February,
     2015,
     Santa Clara, CA,
     pages 29–44
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('eiovar_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('eiovar_bibtex');">BibTeX</a> , 
     <a href="papers/eiovar-fast-2015.pdf">PDF</a> , 
     <a href="https://www.usenix.org/conference/fast15/technical-sessions/presentation/malka">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="eiovar_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Operating systems can defend themselves against misbehaving I/O
         devices and drivers by employing intra-OS protection. With “strict”
         intra-OS protection, the OS uses the IOMMU to map each DMA buffer
         immediately before the DMA occurs and to unmap it immediately after.
         Strict protection is costly due to IOMMU-related hardware overheads,
         motivating “deferred” intra-OS protection, which trades off some
         safety for performance.
     
     <br/><br/>
     
         We investigate the Linux intra-OS protection mapping layer and
         discover that hardware overheads are not exclusively to blame for its
         high cost. Rather, the cost is amplified by the I/O virtual address
         (IOVA) allocator, which regularly induces linear complexity. We find
         that the nature of IOVA allocation requests is inherently simple and
         constrained due to the manner by which I/O devices are used, allowing
         us to deliver constant time complexity with a compact, easy-to-implement
         optimization. Our optimization improves the throughput of standard
         benchmarks by up to 5.5x. It delivers strict protection with
         performance comparable to that of the baseline deferred protection.
     
     <br/><br/>
     
         To generalize our case that OSes drive the IOMMU with suboptimal
         software, we additionally investigate the FreeBSD mapping layer and
         obtain similar findings.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="eiovar_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{malka15-eiovar,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Moshe Malka and Nadav Amit and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Efficient intra-operating system protection against harmful {DMAs}},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {USENIX Conference on File and Storage Technologies (FAST)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2015,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {February},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {29--44},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Santa Clara, CA}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
</ul>
<!-- ==================== 2014 ==================== -->
<!-- ==================== 2014 ==================== -->
<!-- ==================== 2014 ==================== -->
<h3>2014</h3>
<ul>
<!-- ============ pwaexp ============ -->
<li>
<!-- anchor -->
<a name="pwaexp"></a>
<span class="docTitle">
     Experience with using the Parallel Workloads Archive
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dror G. Feitelson, Dan Tsafrir, David Krakov
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">JPDC</span>: Journal of Parallel and Distributed Computing
     </span>
<br/>
<!-- details -->
     October,
     2014,
     pages 2967–2982,
     volume 74,
     number 10
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('pwaexp_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('pwaexp_bibtex');">BibTeX</a> , 
     <a href="papers/pwaexp-jpdc-2014.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1016/j.jpdc.2014.06.013">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="pwaexp_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Workload data is an invaluable resource for the design and
         evaluation of computer systems. However, data quality is always an
         issue. Therefore the experience gained when using data is also a
         precious resource, and both the data and the experience should be
         recorded and made available to other researchers. We demonstrate
         this for the Parallel Workloads Archive, which records job-level
         usage data from many largescale parallel supercomputers, clusters,
         and grids. Data quality problems encountered include missing data,
         inconsistent data, erroneous data, system configuration changes
         during the logging period, and nonrepresentative user
         behavior. Some of these may be countered by filtering out the
         problematic data items. In other cases, being cognizant of the
         problems may affect the decision of which datasets to use.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="pwaexp_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @Article{feitelson14-pwaexp,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dror G. Feitelson and Dan Tsafrir and David Krakov},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Experience with using the {Parallel} {Workloads} {Archive}},</td>
</tr>
<tr>
<td align="right" valign="top">journal</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Journal of Parallel and Distributed Computing (JPDC)},</td>
</tr>
<tr>
<td align="right" valign="top">volume</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       74,</td>
</tr>
<tr>
<td align="right" valign="top">number</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       10,</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2014,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {October},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {2967--2982}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ raasj ============ -->
<li>
<!-- anchor -->
<a name="raasj"></a>
<span class="docTitle">
     The rise of RaaS: resource-as-as-service cloud
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Orna Agmon Ben-Yehuda, Muli Ben-Yehuda, Assaf Schuster, 
            Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">CACM</span>: Communications of the ACM
     </span>
<br/>
<!-- details -->
     July,
     2014,
     volume 57,
     number 7
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('raasj_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('raasj_bibtex');">BibTeX</a> , 
     <a href="papers/raasj-cacm-2014.pdf">PDF</a> , 
     <a href="https://doi.org/10.1145/2627422">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="raasj_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Over the next few years, a new model of buying and selling cloud
         computing resources will evolve. Instead of providers exclusively
         selling server-equivalent virtual machines for relatively long
         periods of time (as done in today's IaaS clouds), they will
         increasingly sell to clients individual resources (such as CPU,
         memory, and I/O resources), reprice them and adjust their quantity
         every few seconds. Instead of allocating resources on a
         First-come First-served basis, they will do so in accordance with
         market-driven supply-and-demand conditions. We term this nascent
         economic model of cloud computing the Resource-as-a-Service (RaaS)
         cloud, and we argue that its rise is the likely culmination of
         recent trends in the construction of Infrastructure-as-a-Service
         (IaaS) clouds and of the economic forces operating on both
         providers and clients.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="raasj_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @Article{ben-yehuda14-raasj,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Orna {Agmon Ben-Yehuda} and Muli Ben-Yehuda and Assaf Schuster and 
            Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {The rise of {RaaS:} resource-as-as-service cloud},</td>
</tr>
<tr>
<td align="right" valign="top">journal</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Communications of the ACM (CACM)},</td>
</tr>
<tr>
<td align="right" valign="top">volume</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       57,</td>
</tr>
<tr>
<td align="right" valign="top">number</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       7,</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2014,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {July}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ vswap ============ -->
<li>
<!-- anchor -->
<a name="vswap"></a>
<span class="docTitle">
     VSwapper: A memory swapper for virtualized environments
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Nadav Amit, Dan Tsafrir, Assaf Schuster
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">ASPLOS '14</span>: ACM International Conference on Architectural Support for Programming Languages and 
                Operating Systems
     </span>
<br/>
<!-- details -->
     March,
     2014,
     Salt Lake City, UT,
     pages 349–366,
     <span style="background-color:#F7BDDE"><a href="http://www.hipeac.org/research/paper-awards/2014/">HiPEAC Paper Award</a></span>
<br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('vswap_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('vswap_bibtex');">BibTeX</a> , 
     <a href="papers/vswapper-asplos-2014.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1145/2541940.2541969">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="vswap_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     The number of guest virtual machines that can be consolidated on one
     physical host is typically limited by the memory size, motivating
     memory overcommitment. Guests are given a choice to either install a
     “balloon” driver to coordinate the overcommitment activity, or to
     experience degraded performance due to uncooperative swapping.
     Ballooning, however, is not a complete solution, as hosts must still
     fall back on uncooperative swapping in various circumstances.
     Additionally, ballooning takes time to accommodate change, and so
     guests might experience degraded performance under changing
     conditions.
     
     <br/><br/>
     
     Our goal is to improve the performance of hosts when they fall back on
     uncooperative swapping and/or operate under changing load conditions.
     We carefully isolate and characterize the causes for the associated
     poor performance, which include various types of superfluous swap
     operations, decayed swap file sequentiality, and ineffective prefetch
     decisions upon page faults. We address these problems by implementing
     VSwapper, a guest-agnostic memory swapper for virtual
     environments that allows efficient, uncooperative overcommitment. With
     inactive ballooning, VSwapper yields up to an order of magnitude
     performance improvement. Combined with ballooning, VSwapper can achieve
     up to double the performance under changing load conditions.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="vswap_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{amit14-vswap,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Nadav Amit and Dan Tsafrir and Assaf Schuster},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {{VSwapper}: {A} memory swapper for virtualized environments},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM International Conference on Architectural Support for Programming Languages and 
                Operating Systems (ASPLOS)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2014,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {March},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {349--366},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Salt Lake City, UT}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ vswappat ============ -->
<li>
<!-- anchor -->
<a name="vswappat"></a>
<span class="docTitle">
     Memory swapper for virtualized environments
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Nadav Amit, Dan Tsafrir, Assaf Schuster
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">Patent</span> Number: US 9811268 B2 (granted: Nov 2017)
     </span>
<br/>
<!-- details -->
     February,
     2014
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('vswappat_bibtex');">BibTeX</a> , 
     <a href="https://www.google.com/patents/US9811268">Html</a>
<br/>
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="vswappat_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @Misc{amit14-vswappat,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Nadav Amit and Dan Tsafrir and Assaf Schuster},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Memory swapper for virtualized environments},</td>
</tr>
<tr>
<td align="right" valign="top">howpublished</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Patent Number: US 9811268 B2 (granted: Nov 2017)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2014,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {February}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
</ul>
<!-- ==================== 2013 ==================== -->
<!-- ==================== 2013 ==================== -->
<!-- ==================== 2013 ==================== -->
<h3>2013</h3>
<ul>
<!-- ============ spotj ============ -->
<li>
<!-- anchor -->
<a name="spotj"></a>
<span class="docTitle">
     Deconstructing Amazon EC2 spot instance pricing
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Orna Agmon Ben-Yehuda, Muli Ben-Yehuda, Assaf Schuster, 
     	Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">TEAC</span>: ACM Transactions on Economics and Computation
     </span>
<br/>
<!-- details -->
     September,
     2013,
     pages 16:1–16:20,
     volume 1,
     number 3
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('spotj_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('spotj_bibtex');">BibTeX</a> , 
     <a href="papers/spotj-teac-2013.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1145/2509413.2509416">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="spotj_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Cloud providers possessing large quantities of spare capacity must
         either incentivize clients to purchase it or suffer losses. Amazon
         is the first cloud provider to address this challenge, by allowing
         clients to bid on spare capacity and by granting resources to
         bidders while their bids exceed a periodically changing spot
         price. Amazon publicizes the spot price but does not disclose how
         it is determined. By analyzing the spot price histories of
         Amazon's EC2 cloud, we reverse engineer how prices are set and
         construct a model that generates prices consistent with existing
         price traces. Our findings suggest that usually prices are not
         market-driven, as sometimes previously assumed. Rather, they are
         likely to be generated most of the time at random from within a
         tight price range via a dynamic hidden reserve price mechanism.
         Our model could help clients make informed bids, cloud providers
         design profitable systems, and researchers design pricing
         algorithms.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="spotj_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @Article{ben-yehuda13-spotj,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Orna {Agmon Ben-Yehuda} and Muli Ben-Yehuda and Assaf Schuster and 
     	Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Deconstructing {Amazon} {EC2} spot instance pricing},</td>
</tr>
<tr>
<td align="right" valign="top">journal</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM Transactions on Economics and Computation (TEAC)},</td>
</tr>
<tr>
<td align="right" valign="top">volume</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       1,</td>
</tr>
<tr>
<td align="right" valign="top">number</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       3,</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2013,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {September},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {16:1--16:20}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ nomish ============ -->
<li>
<!-- anchor -->
<a name="nomish"></a>
<span class="docTitle">
     The nonkernel: a kernel designed for the cloud
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Muli Ben-Yehuda, Omer Peleg, Orna Agmon Ben-Yehuda, Igor
         Smolyar, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">APSYS '13</span>: ACM Asia-Pacific Workshop on Systems
     </span>
<br/>
<!-- details -->
     July,
     2013,
     Singapore,
     pages 4:1–4:7
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('nomish_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('nomish_bibtex');">BibTeX</a> , 
     <a href="papers/inspirinom-apsys-2013.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1145/2500727.2500737">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="nomish_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Infrastructure-as-a-Service (IaaS) cloud computing is causing a
          fundamental shift in the way computing resources are bought,
          sold, and used. We foresee a future whereby every CPU cycle,
          every memory word, and every byte of network bandwidth in the
          cloud would have a constantly changing market-driven price. We
          argue that, in such an environment, the underlying resources
          should be exposed directly to applications without kernel or
          hypervisor involve- ment. We propose the nonkernel, an
          architecture for operating system kernel construction designed
          for such cloud computing platforms. A nonkernel uses modern
          architectural support for machine virtualization to securely
          provide unprivileged user programs with pervasive access to the
          underlying resources.  We motivate the need for the nonkernel, we
          contrast it against its predecessor the exokernel, and we outline
          how one could go about building a nonkernel operating system.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="nomish_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{ben-yehuda13-nomish,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Muli Ben-Yehuda and Omer Peleg and Orna {Agmon Ben-Yehuda} and Igor
         Smolyar and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {The nonkernel: a kernel designed for the cloud},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM Asia-Pacific Workshop on Systems (APSYS)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2013,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {July},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {4:1--4:7},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Singapore}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ simfail ============ -->
<li>
<!-- anchor -->
<a name="simfail"></a>
<span class="docTitle">
     Using disk add-ons to withstand simultaneous disk failures
                with fewer replicas
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Eitan Rosenfeld, Nadav Amit, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">WIVOSCA '13</span>: Workshop on the Interaction amongst Virtualization,
                Operating Systems and Computer Architecture
     </span>
<br/>
<!-- details -->
     June,
     2013,
     Tel Aviv, Israel
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('simfail_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('simfail_bibtex');">BibTeX</a> , 
     <a href="papers/SimFail13wivosca.pdf">PDF</a> , 
     <a href="http://www.ideal.ece.ufl.edu/workshops/wivosca13/wivoscaadv.html">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="simfail_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Contemporary storage systems that utilize replication often
          maintain more than two replicas of each data item, reducing the
          risk of permanent data loss due to simultaneous disk
          failures. The price of the additional copies is smaller usable
          storage space, increased network traffic, and higher power
          consumption. We propose to alleviate this problem with SimFail, a
          storage system that maintains only two replicas and utilizes
          per-disk “add-ons”, which are simple hardware devices
          equipped with relatively small memory that proxy disk I/O
          traffic. SimFail can significantly reduce the risk of data loss
          due to temporally adjacent disk failures by quickly copying
          atrisk data from disks to their add-ons. SIMFAIL can further
          eliminate the risk entirely by maintaining local parity
          information of disks on their add-ons (such that each add-on
          holds the parity of its own disk's data chunks).  We postulate
          that SimFail may open the door for cloud providers to reduce the
          number of data replicas they use from three to two.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="simfail_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{rosenfeld13-simfail,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Eitan Rosenfeld and Nadav Amit and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Using disk add-ons to withstand simultaneous disk failures
                with fewer replicas},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Workshop on the Interaction amongst Virtualization,
                Operating Systems and Computer Architecture (WIVOSCA)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2013,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {June},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Tel Aviv, Israel}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ raidppat ============ -->
<li>
<!-- anchor -->
<a name="raidppat"></a>
<span class="docTitle">
     Using disk add-ons to withstand simultaneous disk failures with fewer replicas
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir, Eitan Rosenfeld
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">Patent</span> Number: US 9535802 B2 (granted: Jan 2017)
     </span>
<br/>
<!-- details -->
     January,
     2013
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('raidppat_bibtex');">BibTeX</a> , 
     <a href="https://www.google.com/patents/US9535802">Html</a>
<br/>
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="raidppat_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @Misc{tsafrir13-raidppat,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir and Eitan Rosenfeld},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Using disk add-ons to withstand simultaneous disk failures with fewer replicas},</td>
</tr>
<tr>
<td align="right" valign="top">howpublished</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Patent Number: US 9535802 B2 (granted: Jan 2017)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2013,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {January}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
</ul>
<!-- ==================== 2012 ==================== -->
<!-- ==================== 2012 ==================== -->
<!-- ==================== 2012 ==================== -->
<h3>2012</h3>
<ul>
<!-- ============ raas ============ -->
<li>
<!-- anchor -->
<a name="raas"></a>
<span class="docTitle">
     The resource-as-a-service (RaaS) cloud
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Orna Agmon Ben-Yehuda, Muli Ben-Yehuda, Assaf Schuster, 
     	Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">HotCloud '12</span>: USENIX Workshop on Hot Topics in Cloud Computing
     </span>
<br/>
<!-- details -->
     June,
     2012,
     Boston, MA
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('raas_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('raas_bibtex');">BibTeX</a> , 
     <a href="papers/HotCloud-2012-RaaS.pdf">PDF</a> , 
     <a href="https://www.usenix.org/conference/hotcloud12/resource-service-raas-cloud">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="raas_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Over the next few years, a new model of buying and selling cloud
         computing resources will evolve. Instead of providers exclusively
         selling server equivalent virtual machines for relatively long
         periods of time (as done in today's IaaS clouds), providers will
         increasingly sell individual resources (such as CPU, memory, and
         I/O resources) for a few seconds at a time. We term this nascent
         economic model of cloud computing the Resource-as-a-Service (RaaS)
         cloud, and we argue that its rise is the likely culmination of
         recent trends in the construction of IaaS clouds and of the
         economic forces operating on both providers and clients.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="raas_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{ben-yehuda12-raas,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Orna {Agmon Ben-Yehuda} and Muli Ben-Yehuda and Assaf Schuster and 
     	Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {The resource-as-a-service {(RaaS)} cloud},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {USENIX Workshop on Hot Topics in Cloud Computing (HotCloud)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2012,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {June},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Boston, MA}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ mreplay ============ -->
<li>
<!-- anchor -->
<a name="mreplay"></a>
<span class="docTitle">
     Feasibility of mutable replay for automated regression
         testing of security updates
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Ilia Kravets, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">RESoLVE '12</span>: Workshop on Runtime Environments, Systems, Layering and Virtualized 
                Environments
     </span>
<br/>
<!-- details -->
     March,
     2012,
     London, UK
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('mreplay_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('mreplay_bibtex');">BibTeX</a> , 
     <a href="papers/RESoLVE-2012-mreplay.pdf">PDF</a> , 
     <a href="http://www.dcs.gla.ac.uk/conferences/resolve12/program.html">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="mreplay_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Applying software patches runs the risk of somehow breaking the
          system, so organizations often prefer to avoid updates or to
          defer them until extensive testing is performed. But unpatched
          software might be compromised, and extensive testing might be
          tedious and time and resource consuming. We consider alleviating
          the problem by utilizing a new type of “mutable” deterministic
          execution replay, which would allow us to (1) run the software
          before and after the patch and to (2) compare the behavior of the
          two versions in a manner that tolerates legitimate differences
          that arise from security patches. The potential advantages of
          this approach are that: it is automatic; it requires no
          programming skills; it is language-agnostic; it works without
          source code; and it can be applied while the system is running
          and serving real production workloads.  In this work, we do not
          implement mutable replay; rather, we assess its
          <i>feasibility</i>. We do so by systematically studying about 200
          security patches applied to the most popular Debian/Linux
          packages and by considering how mutable replay should be
          implemented so as to tolerate execution differences that such
          patches generate.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="mreplay_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{kravets12-mreplay,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Ilia Kravets and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Feasibility of mutable replay for automated regression
         testing of security updates},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Workshop on Runtime Environments, Systems, Layering and Virtualized 
                Environments (RESoLVE)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2012,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {March},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {London, UK}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ eli ============ -->
<li>
<!-- anchor -->
<a name="eli"></a>
<span class="docTitle">
     ELI: bare-metal performance for I/O virtualization
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Abel Gordon, Nadav Amit, Nadav Har'El, Muli Ben-Yehuda,
                 Alex Landau, Assaf Schuster, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">ASPLOS '12</span>: ACM International Conference on Architectural Support for Programming Languages and 
                Operating Systems
     </span>
<br/>
<!-- details -->
     March,
     2012,
     London, UK,
     pages 411–422,
     <span style="background-color:#F7BDDE"><a href="http://researcher.watson.ibm.com/researcher/view_group.php?id=5855">Pat Goldberg Memorial Best Paper Award</a></span>,
     <span style="background-color:#F7BDDE"><a href="http://www.hipeac.org/research/paper-awards/2012/">HiPEAC Paper Award</a></span>
<br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('eli_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('eli_bibtex');">BibTeX</a> , 
     <a href="papers/ASPLOS-2012-ExitlessInterrupts.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1145/2189750.2151020">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="eli_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Direct device assignment enhances the performance of guest virtual
         machines by allowing them to communicate with I/O devices without
         host involvement. But even with device assignment, guests are
         still unable to approach bare-metal performance, because the host
         intercepts all interrupts, including those interrupts generated by
         assigned devices to signal to guests the completion of their I/O
         requests. The host involvement induces multiple unwarranted
         guest/host context switches, which significantly hamper the
         performance of I/O intensive workloads.  To solve this problem, we
         present ELI (ExitLess Interrupts), a software-only approach for
         handling interrupts within guest virtual machines <i>directly</i>
         and <i>securely</i>. By removing the host from the interrupt
         handling path, ELI manages to improve the throughput and latency
         of unmodified, untrusted guests by 1.3x–1.6x, allowing them to
         reach 97%–100% of bare-metal performance even for the most
         demanding I/O-intensive workloads.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="eli_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{gordon12-eli,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Abel Gordon and Nadav Amit and Nadav Har'El and Muli Ben-Yehuda and
                 Alex Landau and Assaf Schuster and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {{ELI}: bare-metal performance for {I/O} virtualization},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM International Conference on Architectural Support for Programming Languages and 
                Operating Systems (ASPLOS)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2012,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {March},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {411--422},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {London, UK}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
</ul>
<!-- ==================== 2011 ==================== -->
<!-- ==================== 2011 ==================== -->
<!-- ==================== 2011 ==================== -->
<h3>2011</h3>
<ul>
<!-- ============ spotprice ============ -->
<li>
<!-- anchor -->
<a name="spotprice"></a>
<span class="docTitle">
     Deconstructing Amazon EC2 spot instance pricing
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Orna Agmon Ben-Yehuda, Muli Ben-Yehuda, Assaf Schuster, 
     	Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">CloudCom '11</span>: IEEE International Conference on Cloud Computing Technology 
     	and Science
     </span>
<br/>
<!-- details -->
     November,
     2011,
     Athens, Greece
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('spotprice_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('spotprice_bibtex');">BibTeX</a> , 
     <a href="papers/Spotprice11CloudCom.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1109/CloudCom.2011.48">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="spotprice_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Cloud providers possessing large quantities of spare capacity must
         either incentivize clients to purchase it or suffer losses. Amazon
         is the first cloud provider to address this challenge, by allowing
         clients to bid on spare capacity and by granting resources to
         bidders while their bids exceed a periodically changing spot
         price. Amazon publicizes the spot price but does not disclose how
         it is determined.  By analyzing the spot price histories of
         Amazon's EC2 cloud, we reverse engineer how prices are set and
         construct a model that generates prices consistent with existing
         price traces. We find that prices are usually not market-driven as
         sometimes previously assumed. Rather, they are typically generated
         at random from within a tight price interval via a dynamic hidden
         reserve price. Our model could help clients make informed bids,
         cloud providers design profitable systems, and researchers design
         pricing algorithms.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="spotprice_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{ben-yehuda11-spotprice,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Orna {Agmon Ben-Yehuda} and Muli Ben-Yehuda and Assaf Schuster and 
     	Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Deconstructing {Amazon} {EC2} spot instance pricing},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {IEEE International Conference on Cloud Computing Technology 
     	and Science (CloudCom)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2011,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {November},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Athens, Greece}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ viommu ============ -->
<li>
<!-- anchor -->
<a name="viommu"></a>
<span class="docTitle">
     vIOMMU: efficient IOMMU emulation
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Nadav Amit, Muli Ben-Yehuda, Dan Tsafrir, Assaf Schuster
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">ATC '11</span>: USENIX Annual Technical Conference
     </span>
<br/>
<!-- details -->
     June,
     2011,
     Portland, Oregon,
     pages 73–86
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('viommu_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('viommu_bibtex');">BibTeX</a> , 
     <a href="papers/VIOMMU11ATC.pdf">PDF</a> , 
     <a href="http://www.usenix.org/events/atc11/tech/">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="viommu_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Direct device assignment, where a guest virtual machine directly
         interacts with an I/O device without host intervention, is
         appealing, because it allows an unmodified (non-hypervisor-aware)
         guest to achieve near-native performance. But device assignment
         for unmodified guests suffers from two serious deficiencies: (1)
         it requires pinning of all the guest's pages, thereby disallowing
         memory overcommitment, and (2) it exposes the guest's memory to
         buggy device drivers.
     
     <br/><br/>
     
         We solve these problems by designing, implementing, and exposing
         an emulated IOMMU (vIOMMU) to the unmodified guest. We employ two
         novel optimizations to make vIOMMU perform well: (1) waiting a few
         milliseconds before tearing down an IOMMU mapping in the hope it
         will be immediately reused “optimistic teardown”, and (2)
         running the vIOMMU on a sidecore, and thereby enabling for the
         first time the use of a sidecore by unmodified guests. Both
         optimizations are highly effective in isolation. The former allows
         bare-metal to achieve 100
         of the two allows an unmodified guest to do the same.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="viommu_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{amit11-viommu,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Nadav Amit and Muli Ben-Yehuda and Dan Tsafrir and Assaf Schuster},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {{vIOMMU}: efficient {IOMMU} emulation},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {USENIX Annual Technical Conference (ATC)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2011,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {June},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {73--86},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Portland, Oregon}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ specupat ============ -->
<li>
<!-- anchor -->
<a name="specupat"></a>
<span class="docTitle">
     A method for guaranteeing program correctness using
       finegrained hardware speculative execution
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir, Robert W. Wisniewski
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">Patent</span> Number: US 9195550 B2 (granted: Nov 2015)
     </span>
<br/>
<!-- details -->
     February,
     2011
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('specupat_bibtex');">BibTeX</a> , 
     <a href="https://www.google.com/patents/US9195550">Html</a>
<br/>
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="specupat_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @Misc{tsafrir11-specupat,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir and Robert W. Wisniewski},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {A method for guaranteeing program correctness using
       finegrained hardware speculative execution},</td>
</tr>
<tr>
<td align="right" valign="top">howpublished</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Patent Number: US 9195550 B2 (granted: Nov 2015)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2011,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {February}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
</ul>
<!-- ==================== 2010 ==================== -->
<!-- ==================== 2010 ==================== -->
<!-- ==================== 2010 ==================== -->
<h3>2010</h3>
<ul>
<!-- ============ keynote ============ -->
<li>
<!-- anchor -->
<a name="keynote"></a>
<span class="docTitle">
     Using inaccurate estimates accurately
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">JSSPP '10</span>: Workshop on Job Scheduling Strategies for Parallel
         Processing
     </span>
<br/>
<!-- details -->
     April,
     2010,
     Atlanta, Georgia,
     pages 208–221,
     LNCS Volume 6253,
     <span style="background-color:#F7BDDE">keynote talk</span>
<br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('keynote_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('keynote_bibtex');">BibTeX</a> , 
     <a href="papers/Keynote10JSSPP.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1007/978-3-642-16505-4_12">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="keynote_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Job schedulers improve the system utilization by requiring users
         to estimate how long their jobs will run and by using this
         information to better pack (or “backfill”) the jobs. But,
         surprisingly, many studies find that deliberately making estimates
         <i>less</i> accurate boosts (or does not affect) the performance,
         which helps explain why production systems still exclusively rely
         on notoriously inaccurate estimates.
     
     <br/><br/>
     
         We prove these studies wrong by showing their methodology is
         erroneous. The studies model an estimate <i>e</i> as being correlated
         with <i>r·F</i> (where <i>r</i> is the runtime of the associated job,
         <i>F</i> is some "badness" factor, and bigger <i>F</i>s imply increased
         inaccuracy).  We show this model is invalid, because: (1) it
         conveys too much information to the scheduler; (2) it induces
         favoritism of short jobs; and (3) it is inherently different than
         real user inaccuracy, which associates 90% of the jobs with
         merely 20 estimate values, hindering the scheduler's ability to
         backfill.
     
     <br/><br/>
     
         We conclude that researchers must stop using multiples of runtimes
         as estimates, or else their results would likely be invalid. We
         develop (and propose to use) a realistic model that preserves the
         estimates' modality and allows to soundly simulate increased
         inaccuracy by, e.g., associating more jobs with the maximal
         runtime allowed (an always-popular estimate, which prevents
         backfilling).
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="keynote_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InCollection{tsafrir10-keynote,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Using inaccurate estimates accurately},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Workshop on Job Scheduling Strategies for Parallel
         Processing (JSSPP)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2010,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {April},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {208--221},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Atlanta, Georgia},</td>
</tr>
<tr>
<td align="right" valign="top">note</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {LNCS Volume 6253}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
</ul>
<!-- ==================== 2009 ==================== -->
<!-- ==================== 2009 ==================== -->
<!-- ==================== 2009 ==================== -->
<h3>2009</h3>
<ul>
<!-- ============ scary-rev1 ============ -->
<li>
<!-- anchor -->
<a name="scary-rev1"></a>
<span class="docTitle">
     SCARY iterator assignment and initialization revision 1
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Robert Klarer, Bjarne Stroustrup, Dan Tsafrir, Michael
         Wong
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
     ISO/IEC <span class="docVenueAbrv">C++ Standards Committee Paper</span> WG21/N2980=09-0170
     </span>
<br/>
<!-- details -->
     October,
     2009,
     Santa Cruz, California
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('scary-rev1_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('scary-rev1_bibtex');">BibTeX</a> , 
     <a href="papers/Scary09Rev1C++Committee.pdf">PDF</a> , 
     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2980.pdf">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="scary-rev1_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     We propose a requirement that a standard container's iterator
         types have no dependency on any type argument apart from the
         container's <tt>value_type</tt>, <tt>difference_type</tt>,
         <tt>pointer</tt> type, and <tt>const_pointer</tt> type. In
         particular, the types of a standard container's iterators should
         not depend on the container's <tt>key_compare</tt>,
         <tt>hasher</tt>, <tt>key_equal</tt>, or <tt>allocator</tt> types.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="scary-rev1_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{klarer09-scary-rev1,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Robert Klarer and Bjarne Stroustrup and Dan Tsafrir and Michael
         Wong},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {SCARY iterator assignment and initialization revision 1},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ISO/IEC C++ Standards Committee Paper WG21/N2980=09-0170},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2009,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {October},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Santa Cruz, California}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ inner ============ -->
<li>
<!-- anchor -->
<a name="inner"></a>
<span class="docTitle">
     Minimizing dependencies within generic classes for faster
                and smaller programs
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir, Robert W. Wisniewski, David F. Bacon, 
           Bjarne Stroustrup
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">OOPSLA '09</span>: ACM SIGPLAN Conference on Object-Oriented
                Programming Systems, Languages, and Applications
     </span>
<br/>
<!-- details -->
     October,
     2009,
     Orlando, Florida,
     pages 425–444
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('inner_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('inner_bibtex');">BibTeX</a> , 
     <a href="papers/MinimizeDependencies09OOPSLA.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1145/1640089.1640121">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="inner_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Generic classes can be used to improve performance by allowing
         compile-time polymorphism.  But the applicability of compile-time
         polymorphism is narrower than that of runtime polymorphism, and it
         might bloat the object code.  We advocate a programming principle
         whereby a generic class should be implemented in a way that
         minimizes the dependencies between its members (nested types,
         methods) and its generic type parameters.  Conforming to this
         principle (1) reduces the bloat and (2) gives rise to a previously
         unconceived manner of using the language that expands the
         applicability of compile-time polymorphism to a wider range of
         problems.  Our contribution is thus a programming technique that
         generates faster and smaller programs.  We apply our ideas to
         GCC's STL containers and iterators, and we demonstrate notable
         speedups and reduction in object code size (real application runs
         1.2x to 2.1x faster and STL code is 1x to 25x smaller).  We
         conclude that standard generic APIs (like STL) should be amended
         to reflect the proposed principle in the interest of efficiency
         and compactness.  Such modifications will not break old code,
         simply increase flexibility.  Our findings apply to languages like
         C++, C#, and D, which realize generic programming through multiple
         instantiations.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="inner_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{tsafrir09-inner,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir and Robert W. Wisniewski and David F. Bacon and 
           Bjarne Stroustrup},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Minimizing dependencies within generic classes for faster
                and smaller programs},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM SIGPLAN Conference on Object-Oriented
                Programming Systems, Languages, and Applications (OOPSLA)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2009,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {October},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {425--444},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Orlando, Florida}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ scary ============ -->
<li>
<!-- anchor -->
<a name="scary"></a>
<span class="docTitle">
     SCARY iterator assignment and initialization
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Robert Klarer, Bjarne Stroustrup, Dan Tsafrir, Michael
         Wong
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
     ISO/IEC <span class="docVenueAbrv">C++ Standards Committee Paper</span> WG21/N2913=09-0103
     </span>
<br/>
<!-- details -->
     July,
     2009,
     Frankfurt, Germany
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('scary_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('scary_bibtex');">BibTeX</a> , 
     <a href="papers/Scary09C++Committee.pdf">PDF</a> , 
     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2913.pdf">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="scary_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     We propose a requirement that a standard container's iterator
         types have no dependency on any type argument apart from the
         container's <tt>value_type</tt>, <tt>difference_type</tt>,
         <tt>pointer</tt> type, and <tt>const_pointer</tt> type. In
         particular, the types of a standard container's iterators should
         not depend on the container's <tt>key_compare</tt>,
         <tt>hasher</tt>, <tt>key_equal</tt>, or <tt>allocator</tt> types.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="scary_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{klarer09-scary,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Robert Klarer and Bjarne Stroustrup and Dan Tsafrir and Michael
         Wong},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {SCARY iterator assignment and initialization},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ISO/IEC C++ Standards Committee Paper WG21/N2913=09-0103},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2009,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {July},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Frankfurt, Germany}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
</ul>
<!-- ==================== 2008 ==================== -->
<!-- ==================== 2008 ==================== -->
<!-- ==================== 2008 ==================== -->
<h3>2008</h3>
<ul>
<!-- ============ tocttou:tos ============ -->
<li>
<!-- anchor -->
<a name="tocttou:tos"></a>
<span class="docTitle">
     Portably solving file races with hardness amplification
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir, Tomer Hertz, Dilma Da Silva, David Wagner
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">TOS</span>: ACM Transactions on Storage
     </span>
<br/>
<!-- details -->
     November,
     2008,
     page 9,
     volume 4,
     number 3
     <br/>
<!-- availabilities -->
<a href="#path-res">
     Superseded by</a> , 
     <a href="javascript:toggleblocks('tocttou:tos_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('tocttou:tos_bibtex');">BibTeX</a> , 
     <a href="papers/Tocttou08TOS.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1145/1416944.1416948">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="tocttou:tos_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     The file-system API of contemporary systems makes programs vulnerable
           to TOCTTOU (time-of-check-to-time-of-use) race conditions.
           Existing solutions either help users to detect these problems (by
           pinpointing their locations in the code), or prevent the problem
           altogether (by modifying the kernel or its API).  
           But the latter alternative is not prevalent, and the former is just the
           first step: programmers must still address TOCTTOU flaws within the
           limits of the existing API with which several important  tasks cannot 
           be accomplished in a portable straightforward manner.
           Recently, Dean and Hu~[2004] addressed this problem and suggested a
           probabilistic hardness amplification approach that alleviated the
           matter.  
           Alas, shortly after, Borisov et al.~[2005] responded
           with an attack termed  
           “filesystem maze” that defeated the new approach. 
     
     <br/><br/>
     
           We begin by noting that mazes constitute a generic way to
           deterministically win many TOCTTOU races (gone are the days when the
           probability was small).
           In the face of this threat, we (1) develop a new user-level defense
           that can withstand mazes, and (2) show that our method is undefeated
           even by much stronger hypothetical attacks that provide the adversary
           program with ideal conditions to win the race (enjoying complete and
           instantaneous knowledge about the defending program's actions and
           being able to perfectly synchronize accordingly).  
           The fact that our approach is immune to these unrealistic attacks suggests
           it can be used as a simple and portable solution to a large class of
           TOCTTOU vulnerabilities, without requiring modifications to the
           underlying operating system.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="tocttou:tos_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @Article{tsafrir08-tocttou:tos,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir and Tomer Hertz and Dilma Da Silva and David Wagner},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Portably solving file races with hardness amplification},</td>
</tr>
<tr>
<td align="right" valign="top">journal</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM Transactions on Storage (TOS)},</td>
</tr>
<tr>
<td align="right" valign="top">volume</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       4,</td>
</tr>
<tr>
<td align="right" valign="top">number</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       3,</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2008,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {November},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       9</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ path-res ============ -->
<li>
<!-- anchor -->
<a name="path-res"></a>
<span class="docTitle">
     Portably preventing file race attacks
         with user-mode path resolution
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir, Tomer Hertz, David Wagner, Dilma Da Silva
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">Technical Report</span> RC24572, IBM T. J. Watson Research Center
     </span>
<br/>
<!-- details -->
     June,
     2008,
     Yorktown Heights, New York,
     submitted
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('path-res_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('path-res_bibtex');">BibTeX</a> , 
     <a href="papers/PathRes08TR.pdf">PDF</a> , 
     <a href="http://domino.watson.ibm.com/library/CyberDig.nsf/1e4115aea78b6e7c85256b360066f0d4/c4028924309762d18525746e004a4feb">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="path-res_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     The filesystem API of contemporary systems exposes programs to
         TOCTTOU (time of check to time of use) race-condition
         vulnerabilities, which occur between pairs of check/use system
         calls that involve a name of a file.  Existing solutions either
         help programmers to detect such races (by pinpointing their
         location) or prevent them altogether (by altering the operating
         system).  But the latter alternative is not prevalent, and the
         former is just the first step: programmers must still address
         TOCTTOU flaws within the limits of the existing API with which
         several important tasks can not be safely accomplished in a
         portable straightforward manner.  The recent “filesystem maze”
         attack further worsens the problem by allowing adversaries to
         deterministically win races and thus refuting the common
         perception that the risk is small.  In the face of this threat, we
         develop a new algorithm that allows programmers to effectively
         aggregate a vulnerable pair of distinct system calls into a single
         operation that is executed “atomically”.  This is achieved by
         emulating one kernel functionality in user mode: the filepath
         resolution.  The surprisingly simple resulting algorithm
         constitutes a portable solution to a large class of TOCTTOU
         vulnerabilities, without requiring modifications to the underlying
         operating system.  In contrast to our previous work, the new
         algorithm is deterministic and incurs significantly less overhead.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="path-res_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @TechReport{tsafrir08-path-res,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir and Tomer Hertz and David Wagner and Dilma Da Silva},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Portably preventing file race attacks
         with user-mode path resolution},</td>
</tr>
<tr>
<td align="right" valign="top">institution</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {IBM T. J. Watson Research Center},</td>
</tr>
<tr>
<td align="right" valign="top">number</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {RC24572},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2008,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {June},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Yorktown Heights, New York},</td>
</tr>
<tr>
<td align="right" valign="top">note</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {(submitted for publication)}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ priv ============ -->
<li>
<!-- anchor -->
<a name="priv"></a>
<span class="docTitle">
     The murky issue of changing process identity: revising “setuid demystified”
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir, Dilma Da Silva, David Wagner
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">USENIX ;login</span>
</span>
<br/>
<!-- details -->
     June,
     2008,
     pages 55–66,
     volume 33,
     number 3
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('priv_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('priv_bibtex');">BibTeX</a> , 
     <a href="papers/Identity08login.pdf">PDF</a> , 
     <a href="http://www.usenix.org/publications/login/2008-06/index.html">Definitive</a> , 
     <a href="http://code.google.com/p/change-process-identity/">Software</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="priv_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Dropping unneeded process privileges promotes security, but is
         notoriously error-prone due to confusing set∗id system  
         calls with unclear semantics and subtle portability issues. 
         To make things worse, existing recipes to accomplish the task are
         lacking, related manuals can be misleading, and the
         associated kernel subsystem might contain bugs.   
         We therefore proclaim the system as untrustworthy when it comes to the
         subject matter and suggest a defensive easy-to-use solution that 
         addresses all concerns.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="priv_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @Article{tsafrir08-priv,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir and Dilma Da Silva and David Wagner},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {The murky issue of changing process identity: revising ``setuid demystified''},</td>
</tr>
<tr>
<td align="right" valign="top">journal</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {USENIX ;login},</td>
</tr>
<tr>
<td align="right" valign="top">volume</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       33,</td>
</tr>
<tr>
<td align="right" valign="top">number</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       3,</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2008,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {June},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {55--66}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ tocttou ============ -->
<li>
<!-- anchor -->
<a name="tocttou"></a>
<span class="docTitle">
     Portably solving file TOCTTOU races with hardness amplification
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir, Tomer Hertz, David Wagner, Dilma Da Silva
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">FAST '08</span>: USENIX Conference on File and Storage Technologies
     </span>
<br/>
<!-- details -->
     February,
     2008,
     San Jose, California,
     pages 189–206,
     <span style="background-color:#F7BDDE">awarded Best Paper</span>,
     <span style="background-color:#F7BDDE"><a href="http://researcher.watson.ibm.com/researcher/view_group.php?id=5855">Pat Goldberg Memorial Best Paper Award</a></span>
<br/>
<!-- availabilities -->
<a href="#path-res">
     Superseded by</a> , 
     <a href="javascript:toggleblocks('tocttou_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('tocttou_bibtex');">BibTeX</a> , 
     <a href="papers/Tocttou08FAST.pdf">PDF</a> , 
     <a href="http://www.usenix.org/events/fast08/tech/tsafrir.html">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="tocttou_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     The file-system API of contemporary systems makes programs
         vulnerable to TOCTTOU (time of check to time of use) race
         conditions.  Existing solutions either help users to detect these
         problems (by pinpointing their locations in the code), or prevent
         the problem altogether (by modifying the kernel or its API).  The
         latter alternative is not prevalent, and the former is just the
         first step: programmers must still address TOCTTOU flaws within
         the limits of the existing API with which several important tasks
         can not be accomplished in a portable straightforward manner.
         Recently, Dean and Hu addressed this problem and suggested a
         probabilistic hardness amplification approach that alleviated the
         matter.  Alas, shortly after, Borisov et al. responded with an
         attack termed “filesystem maze” that defeated the new approach.
     
     <br/><br/>
     
         We begin by noting that mazes constitute a generic way to
         deterministically win many TOCTTOU races (gone are the days when
         the probability was small).  In the face of this threat, we (1)
         develop a new user-level defense that can withstand mazes, and (2)
         show that our method is undefeated even by much stronger
         hypothetical attacks that provide the adversary program with ideal
         conditions to win the race (enjoying complete and instantaneous
         knowledge about the defending program's actions and being able to
         perfectly synchronize accordingly).  The fact that our approach is
         immune to these unrealistic attacks suggests it can be used as a
         simple and portable solution to a large class of TOCTTOU
         vulnerabilities, without requiring modifications to the underlying
         operating system.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="tocttou_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{tsafrir08-tocttou,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir and Tomer Hertz and David Wagner and Dilma Da Silva},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Portably solving file {TOCTTOU} races with hardness amplification},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {USENIX Conference on File and Storage Technologies (FAST)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2008,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {February},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {189--206},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {San Jose, California}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ specialized ============ -->
<li>
<!-- anchor -->
<a name="specialized"></a>
<span class="docTitle">
     Specialized execution environments
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Maria Butrico, Dilma Da Silva, Orran Krieger, Michal Ostrowski, 
         Bryan Rosenburg, Dan Tsafrir, Eric Van Hensbergen, Robert W. Wisniewski, 
         Jimi Xenidis
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">OSR</span>: ACM Operating Systems Review
     </span>
<br/>
<!-- details -->
     January,
     2008,
     pages 106–107,
     volume 42,
     number 1
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('specialized_bibtex');">BibTeX</a> , 
     <a href="papers/Specialized08OSR.pdf">PDF</a> , 
     <a href="http://doi.acm.org/10.1145/1341312.1341335">Definitive</a>
<br/>
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="specialized_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @Article{butrico08-specialized,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Maria Butrico and Dilma Da Silva and Orran Krieger and Michal Ostrowski and 
         Bryan Rosenburg and Dan Tsafrir and Eric Van Hensbergen and Robert W. Wisniewski and 
         Jimi Xenidis},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Specialized execution environments},</td>
</tr>
<tr>
<td align="right" valign="top">journal</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM Operating Systems Review (OSR)},</td>
</tr>
<tr>
<td align="right" valign="top">volume</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       42,</td>
</tr>
<tr>
<td align="right" valign="top">number</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       1,</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2008,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {January},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {106--107}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
</ul>
<!-- ==================== 2007 ==================== -->
<!-- ==================== 2007 ==================== -->
<!-- ==================== 2007 ==================== -->
<h3>2007</h3>
<ul>
<!-- ============ shake ============ -->
<li>
<!-- anchor -->
<a name="shake"></a>
<span class="docTitle">
     Reducing performance evaluation sensitivity and variability
         by input shaking
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir, Keren Ouaknine, Dror G. Feitelson
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">MASCOTS '07</span>: IEEE International Symposium on Modeling, Analysis, and
         Simulation of Computer and Telecommunication Systems
     </span>
<br/>
<!-- details -->
     October,
     2007,
     Istanbul, Turkey,
     pages 231–237
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('shake_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('shake_bibtex');">BibTeX</a> , 
     <a href="papers/Shake07MASCOTS.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1109/MASCOTS.2007.58">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="shake_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Simulations sometimes lead to observed sensitivity to
         configuration parameters as well as inconsistent performance
         results. The question is then what is the true effect and what is
         a coincidental artifact of the evaluation. The shaking methodology
         answers this by executing multiple simulations under small
         perturbations to the input workload, and calculating the average
         performance result; if the effect persists we can be more
         confident that it is real, whereas if it disappears it was an
         artifact. We present several examples where the sensitivity that
         appears in results based on a single evaluation is eliminated or
         considerably reduced by the shaking methodology. While our
         examples come from evaluations of scheduling algorithms for
         supercomputers, we believe the method has wider applicability.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="shake_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{tsafrir07-shake,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir and Keren Ouaknine and Dror G. Feitelson},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Reducing performance evaluation sensitivity and variability
         by input shaking},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {IEEE International Symposium on Modeling, Analysis, and
         Simulation of Computer and Telecommunication Systems
         (MASCOTS)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2007,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {October},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {231--237},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Istanbul, Turkey}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ cheat ============ -->
<li>
<!-- anchor -->
<a name="cheat"></a>
<span class="docTitle">
     Secretly monopolizing the CPU without superuser privileges
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir, Yoav Etsion, Dror G. Feitelson
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">USENIX Security</span> Symposium
     </span>
<br/>
<!-- details -->
     August,
     2007,
     Boston, Massachusetts,
     pages 239–256
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('cheat_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('cheat_bibtex');">BibTeX</a> , 
     <a href="papers/Cheat07Security.pdf">PDF</a> , 
     <a href="http://www.usenix.org/events/sec07/tech/tsafrir.html">Definitive</a>
<!-- coverages -->
     , <span style="background-color:#F7BDDE">Coverage</span>:
     <a href="http://it.slashdot.org/article.pl?sid=07/07/11/1421209">Slashdot</a> , 
     <a href="http://arstechnica.com/news.ars/post/20070711-security-paper-shows-how-applications-can-steal-cpu-cycles.html">
     Ars Technica</a> , 
     <a href="http://technews.acm.org/archives.cfm?fo=2007-07-jul/jul-13-2007.html#319913">
     ACM TechNews</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="cheat_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     We describe a “cheat” attack, allowing an ordinary process to
         hijack any desirable percentage of the CPU cycles without
         requiring superuser/administrator privileges.  Moreover, the
         nature of the attack is such that, at least in some systems,
         listing the active processes will erroneously show the cheating
         process as not using any CPU resources: the “missing” cycles
         would either be attributed to some other process or not be
         reported at all (if the machine is otherwise idle).  Thus, certain
         malicious operations generally believed to have required
         overcoming the hardships of obtaining root access and installing a
         rootkit, can actually be launched by non-privileged users in a
         straightforward manner, thereby making the job of a malicious
         adversary that much easier.  We show that most major
         general-purpose operating systems are vulnerable to the cheat
         attack, due to a combination of how they account for CPU usage and
         how they use this information to prioritize competing processes.
         Furthermore, recent scheduler changes attempting to better support
         interactive workloads increase the vulnerability to the attack,
         and naive steps taken by certain systems to reduce the danger are
         easily circumvented.  We show that the attack can nevertheless be
         defeated, and we demonstreate this by implementing a patch for
         Linux that eliminates the problem with negligible
         overhead.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="cheat_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{tsafrir07-cheat,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir and Yoav Etsion and Dror G. Feitelson},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Secretly monopolizing the {CPU} without superuser privileges},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {USENIX Security Symposium},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2007,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {August},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {239--256},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Boston, Massachusetts}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ context ============ -->
<li>
<!-- anchor -->
<a name="context"></a>
<span class="docTitle">
     The context-switch overhead inflicted by hardware
         interrupts (and the enigma of do-nothing loops)
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">ExpCS '07</span>: ACM Workshop on Experimental Computer Science
     </span>
<br/>
<!-- details -->
     June,
     2007,
     San-Diego, California,
     page 4
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('context_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('context_bibtex');">BibTeX</a> , 
     <a href="papers/Context07ExpCS.pdf">PDF</a> , 
     <a href="http://doi.acm.org/10.1145/1281700.1281704">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="context_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     The overhead of a context switch is typically associated with
         multitasking, where several applications share a processor.  But
         even if only one runnable application is present in the system and
         supposedly runs alone, it is still repeatedly preempted in favor
         of a different thread of execution, namely, the operating system
         that services periodic clock interrupts.  We employ two
         complementing methodologies to measure the overhead incurred by
         such events and obtain contradictory results.
     
     <br/><br/>
     
         The first methodology systematically changes the interrupt
         frequency and measures by how much this prolongs the duration of a
         program that sorts an array.  The overall overhead is found to be
         0.5-1.5% at 1000 Hz, linearly proportional to the tick rate, and
         steadily declining as the speed of processors increases.  If the
         kernel is configured such that each tick is slowed down by an
         access to an external time source, then the <i>direct</i> overhead
         dominates.  Otherwise, the relative weight of the <i>indirect</i>
         portion is steadily growing with processors' speed, accounting for
         up to 85% of the total.
     
     <br/><br/>
     
         The second methodology repeatedly executes a simplistic loop
         (calibrated to take 1ms), measures the actual execution time, and
         analyzes the perturbations.  Some loop implementations yield
         results similar to the above, but others indicate that the
         overhead is actually an order of magnitude bigger, or worse.  The
         phenomenon was observed on IA32, IA64, and Power processors, the
         latter being part of the \textsf{ASC Purple} supercomputer.
         Importantly, the effect is greatly amplified for parallel jobs,
         where one late thread holds up all its peers, causing a slowdown
         that is dominated by the per-node latency (numerator) and the job
         granularity (denominator).  We trace the bizarre effect to an
         unexplained interrupt/loop interaction; the question of whether
         this hardware misfeature is experienced by real applications
         remains open.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="context_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{tsafrir07-context,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {The context-switch overhead inflicted by hardware
         interrupts (and the enigma of do-nothing loops)},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM Workshop on Experimental Computer Science (ExpCS)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2007,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {June},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       4,</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {San-Diego, California}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ pred ============ -->
<li>
<!-- anchor -->
<a name="pred"></a>
<span class="docTitle">
     Backfilling using system-generated predictions rather than
         user runtime estimates
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir, Yoav Etsion, Dror G. Feitelson
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">TPDS</span>: IEEE Transactions on Parallel and Distributed Systems
     </span>
<br/>
<!-- details -->
     June,
     2007,
     pages 789–803,
     volume 18,
     number 6
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('pred_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('pred_bibtex');">BibTeX</a> , 
     <a href="papers/Pred07TPDS.pdf">PDF</a> , 
     <a href="http://doi.ieeecomputersociety.org/10.1109/TPDS.2007.70606">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="pred_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     The most commonly used scheduling algorithm for parallel
         supercomputers is FCFS with backfilling, as originally introduced
         in the EASY scheduler.  Backfilling means that short jobs are
         allowed to run ahead of their time provided they do not delay
         previously queued jobs (or at least the first queued job).  To
         make such determinations possible, users are required to provide
         estimates of how long jobs will run, and jobs that violate these
         estimates are killed.  Empirical studies have repeatedly shown
         that user estimates are inaccurate, and that system-generated
         predictions based on history may be significantly better.
         However, predictions have not been incorporated into production
         schedulers, partially due to a misconception (that we resolve)
         claiming inaccuracy actually improves performance, but mainly
         because underprediction is technically unacceptable: users will
         not tolerate jobs being killed just because system predictions
         were too short.  We solve this problem by divorcing kill-time from
         the runtime prediction, and correcting predictions adaptively as
         needed if they are proved wrong.  The end result is a surprisingly
         simple scheduler, which requires minimal deviations from current
         practices (e.g. using FCFS as the basis), and behaves exactly
         like EASY as far as users are concerned; nevertheless, it achieves
         significant improvements in performance, predictability, and
         accuracy.  Notably, this is based on a very simple runtime
         predictor that just averages the runtimes of the last two jobs by
         the same user; counterintuitively, our results indicate that using
         recent data is more important than mining the history for similar
         jobs.  All the techniques suggested in this paper can be used to
         enhance any backfilling algorithm, and are not limited to EASY.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="pred_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @Article{tsafrir07-pred,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir and Yoav Etsion and Dror G. Feitelson},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Backfilling using system-generated predictions rather than
         user runtime estimates},</td>
</tr>
<tr>
<td align="right" valign="top">journal</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {IEEE Transactions on Parallel and Distributed Systems (TPDS)},</td>
</tr>
<tr>
<td align="right" valign="top">volume</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       18,</td>
</tr>
<tr>
<td align="right" valign="top">number</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       6,</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2007,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {June},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {789--803}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ klogger ============ -->
<li>
<!-- anchor -->
<a name="klogger"></a>
<span class="docTitle">
     Fine grained kernel logging with KLogger: experience and
         insights
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Yoav Etsion, Dan Tsafrir, Scott Kirkpatrick, 
         Dror G. Feitelson
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">EuroSys '07</span>: ACM Europran Conference on Computer Systems
     </span>
<br/>
<!-- details -->
     March,
     2007,
     Lisbon, Portugal,
     pages 259–274
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('klogger_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('klogger_bibtex');">BibTeX</a> , 
     <a href="papers/Klogger07EuroSys.pdf">PDF</a> , 
     <a href="http://doi.acm.org/10.1145/1272998.1273023">Definitive</a> , 
     <a href="http://www.cs.huji.ac.il/~etsman/klogger">Software</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="klogger_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Understanding the detailed behavior of an operating system is
         crucial for making informed design decisions.  But such an
         understanding is very hard to achieve, due to the increasing
         complexity of such systems and the fact that they are implemented
         and maintained by large and diverse groups of developers.  Tools
         like KLogger — presented in this paper — can help by enabling
         fine-grained logging of system events and the sharing of a logging
         infrastructure between multiple developers and researchers,
         facilitating a methodology where design evaluation can be an
         integral part of kernel development.  We demonstrate the need for
         such methodology by a host of case studies, using KLogger to
         better understand various kernel subsystems in Linux, and
         pinpointing overheads and problems therein.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="klogger_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{etsion07-klogger,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Yoav Etsion and Dan Tsafrir and Scott Kirkpatrick and 
         Dror G. Feitelson},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Fine grained kernel logging with {KLogger:} experience and
         insights},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM Europran Conference on Computer Systems (EuroSys)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2007,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {March},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {259--274},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Lisbon, Portugal}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
</ul>
<!-- ==================== 2006 ==================== -->
<!-- ==================== 2006 ==================== -->
<!-- ==================== 2006 ==================== -->
<h3>2006</h3>
<ul>
<!-- ============ huc ============ -->
<li>
<!-- anchor -->
<a name="huc"></a>
<span class="docTitle">
     Process prioritization using output production: scheduling
         for multimedia
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Yoav Etsion, Dan Tsafrir, Dror G. Feitelson
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">TOMM</span>: ACM Transactions on Multimedia Computing, Communications
         and Applications
     </span>
<br/>
<!-- details -->
     November,
     2006,
     pages 318–342,
     volume 2,
     number 4
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('huc_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('huc_bibtex');">BibTeX</a> , 
     <a href="papers/HuCsched06TOMCCAP.pdf">PDF</a> , 
     <a href="http://doi.acm.org/10.1145/1201730.1201734">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="huc_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Desktop operating systems such as Windows and Linux base
         scheduling decisions on CPU consumption: processes that consume
         fewer CPU cycles are prioritized, assuming that interactive 
         processes gain from this since they spend most of their time
         waiting for user input. However, this doesn't work for modern
         multimedia applications which require significant CPU
         resources. We therefore suggest a new metric to identify
         interactive processes by explicitly measuring interactions with
         the user, and we use it to design and implement a process
         scheduler. Measurements using a variety of applications indicate
         that this scheduler is very effective in distinguishing between
         competing interactive and noninteractive processes.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="huc_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @Article{etsion06-huc,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Yoav Etsion and Dan Tsafrir and Dror G. Feitelson},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Process prioritization using output production: scheduling
         for multimedia},</td>
</tr>
<tr>
<td align="right" valign="top">journal</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM Transactions on Multimedia Computing, Communications
         and Applications (TOMM)},</td>
</tr>
<tr>
<td align="right" valign="top">volume</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2,</td>
</tr>
<tr>
<td align="right" valign="top">number</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       4,</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2006,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {November},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {318--342}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ ticks ============ -->
<li>
<!-- anchor -->
<a name="ticks"></a>
<span class="docTitle">
     Stop polling! The case against OS ticks
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir, Yoav Etsion, Dror G. Feitelson
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">OSDI '06</span>: USENIX Symposium on Operating Systems Design and
         Implementation
     </span>
<br/>
<!-- details -->
     November,
     2006,
     Seattle, Washington,
     Poster Session
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('ticks_bibtex');">BibTeX</a> , 
     <a href="papers/Ticks06OSDI.pdf">PDF</a> , 
     <a href="http://www.usenix.org/events/osdi06/poster.html">Definitive</a> , 
     <a href="papers/Ticks06OSDI-poster.ppt">Poster</a>
<br/>
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="ticks_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{tsafrir06-ticks,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir and Yoav Etsion and Dror G. Feitelson},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Stop polling! {The} case against {OS} ticks},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {USENIX Symposium on Operating Systems Design and
         Implementation (OSDI)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2006,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {November},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Seattle, Washington},</td>
</tr>
<tr>
<td align="right" valign="top">note</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Poster Session}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ bfdyn ============ -->
<li>
<!-- anchor -->
<a name="bfdyn"></a>
<span class="docTitle">
     The dynamics of backfilling: solving the mystery of why
         increased inaccuracy may help
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir, Dror G. Feitelson
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">IISWC '06</span>: IEEE International Symposium on Workload Characterization
     </span>
<br/>
<!-- details -->
     October,
     2006,
     San Jose, California,
     pages 131–141
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('bfdyn_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('bfdyn_bibtex');">BibTeX</a> , 
     <a href="papers/BackfillDyn06IISWC.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1109/IISWC.2006.302737">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="bfdyn_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Parallel job scheduling with backfilling requires users to provide
         runtime estimates, used by the scheduler to better pack the jobs.
         Studies of the impact of such estimates on performance have
         modeled them using a “badness factor” <i>f ≥ 0</i> in an attempt to
         capture their inaccuracy (given a runtime <i>r</i>, the estimate is
         uniformly distributed in <i>[r, (f+1) · r]</i>).  Surprisingly,
         inaccurate estimates (<i>f&gt;0</i>) yielded better performance than
         accurate ones (<i>f=0</i>).  We explain this by a “heel and toe”
         dynamics that, with <i>f&gt;0</i>, cause backfilling to approximate
         shortest-job first scheduling.  We further find the effect of
         systematically increasing <i>f</i> is V-shaped: average wait time and
         slowdown initially drop, only to rise later on.  This happens
         because higher <i>f</i>s create bigger “holes” in the schedule
         (longer jobs can backfill) and increase the randomness (more long
         jobs appear as short), thus overshadowing the initial heel-and-toe
         preference for shorter jobs.
     
     <br/><br/>
     
         The bottom line is that <i>artificial</i> inaccuracy generated by
         multiplying (real or perfect) estimates by a factor is (1) just a
         scheduling technique that trades off fairness for performance, and
         is (2) ill-suited for studying the effect of <i>real</i>
         inaccuracy.  Real estimates are modal (90% of the jobs use the
         same 20 estimates) and bounded by a maximum (usually the most
         popular estimate).  Therefore, when performing an evaluation,
         “increased inaccuracy” should translate to increased modality.
         Unlike multiplying, this indeed worsens performance as one would
         intuitively expect.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="bfdyn_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{tsafrir06-bfdyn,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir and Dror G. Feitelson},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {The dynamics of backfilling: solving the mystery of why
         increased inaccuracy may help},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {IEEE International Symposium on Workload Characterization
         (IISWC)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2006,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {October},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {131--141},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {San Jose, California}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ phd ============ -->
<li>
<!-- anchor -->
<a name="phd"></a>
<span class="docTitle">
     Modeling, evaluating, and improving the performance of
         supercomputer scheduling
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">PhD</span>: Technical Report 2006-78, School of Computer Science and
         Engineering, the Hebrew University
     </span>
<br/>
<!-- details -->
     September,
     2006,
     Jerusalem, Israel
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('phd_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('phd_bibtex');">BibTeX</a> , 
     <a href="papers/Tsafrir06PhD.pdf">PDF</a> , 
     <a href="http://leibniz.cs.huji.ac.il/anon?View=1&amp;num=1&amp;pid[1]=929&amp;abstract=1">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="phd_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     The most popular scheduling policy for parallel systems is FCFS
         with backfilling (a.k.a. “EASY” scheduling), where short jobs
         are allowed to run ahead of their time provided they do not delay
         previously queued jobs (or at least the first queued job).  This
         mandates users to provide estimates of how long jobs will run, and
         jobs that violate these estimates are killed so as not to violate
         subsequent commitments.  The de-facto standard of evaluating the
         impact of inaccurate estimates on performance has been to use a
         “badness factor” <i>f ≥ 0</i>, such that given a runtime <i>r</i>, the
         associated estimate is uniformly distributed in <i>[r, r ·
         (f+1)]</i>, or is simply <i>r·(f+1)</i>.  The underlying assumption
         was that bigger <i>f</i>s imply worse information.
     
     <br/><br/>
     
         Surprisingly, inaccurate estimates (<i>f&gt;0</i>) yield better
         performance than accurate ones (<i>f=0</i>), a fact that has repeatedly
         produced statements like “inaccurate estimates actually improve
         performance” or “what the scheduler doesn't know won't hurt
         it”, in many independent studies.  This has promoted the
         perception that estimates are “unimportant”.  At the same time,
         other studies noted that real user estimates are inaccurate, and
         that system-generated predictions based on history can do better.
         But predictions were never incorporated into production
         schedulers, partially due the aforementioned perception that
         inaccuracy actually helps, partially because suggested predictors
         were too complex, and partially because underprediction is
         technically unacceptable, as users will not tolerate jobs being
         killed just because system predictions were too short.  All
         attempts to solve the latter technicality yielded algorithms that
         are inappropriate for many supercomputing settings (e.g. using
         preemption, assuming all jobs are restartable, etcetera).
     
     <br/><br/>
     
         This work has four major contributions.  <b>First</b>, we show
         that the “inaccuracy helps” common wisdom is merely an
         unwarranted artifact of the erroneous manner in which inaccurate
         estimates have been modeled, and that increased accuracy actually
         improves performance.  Specifically, previously observed
         improvements turn out to be due to a “heel and toe” dynamics
         that, with <i>f&gt;0</i>, cause backfilling to approximate shortest-job
         first scheduling.  We show that multiplying estimates by a factor
         translates to trading off fairness for performance, and that this
         reasoning works regardless of whether the values being multiplied
         are actual runtimes (“perfect estimates”) or the flawed
         estimates that are supplied by users.  We further show that the
         more accurate the values we multiply, the better the resulting
         performance.  Thus, better estimates actually improve performance,
         and multiplying is in fact a scheduling <i>policy</i> that
         exercises the fairness/performance tradeoff.  Regardless,
         multiplying is anything but representative of real inaccuracy, as
         outlined next.
     
     <br/><br/>
     
         Our <b>second</b> contribution is developing a more
         representative model of estimates that, from now on, will allow
         for a valid evaluation of the effect of inaccurate estimates.  It
         is largely based on noting that human users repeatedly use the
         same “round” values (ten minutes, one hour etc.) and on the
         invariant that 90% of the jobs use the same 20 estimates.
         Importantly, the most popular estimate is typically the maximal
         allowed.  As a result, the jobs associated with this estimate
         cannot be backfilled, and indeed, the more this value is used, the
         more EASY resembles plain FCFS.  Thus, to artificially increase
         the inaccuracy one should e.g. associate more jobs with the
         maximum (a realistic manipulation), <i>not</i> multiply by a
         greater factor (a bogus boost of performance).
     
     <br/><br/>
     
         Our <b>third</b> contribution exploits the above understandings
         to devise a new scheduler that is able to automatically improve
         the quality of estimates and put this into productive use in the
         context of EASY, while preserving its attractive simple batch
         essence and refraining from any unacceptable assumptions.
         Specifically, the problem of underprediction is solved by
         divorcing kill-time from the runtime prediction, and correcting
         predictions adaptively at runtime as needed, if they are proved
         wrong.  The result is a surprisingly simple scheduler, which
         requires minimal deviations from current practices, and behaves
         exactly like EASY as far as users are concerned.  Nevertheless, it
         achieves significant improvements in performance, predictability,
         and accuracy.  Notably, this is based on a very simple runtime
         predictor that just averages the runtimes of the last two jobs by
         the same user; counterintuitively, our results indicate that using
         recent data is more important than saving and mining the history
         for similar jobs, as was done by previous work.  For further
         performance enhancements, we propose to exploit the “heel and
         toe” understanding: explicitly using a shortest job
         <i>backfilled</i> first (SJBF) backfilling order.  This directly
         leads to a performance improvements similar to those previously
         attributed to stunts like multiplying estimates.  By still
         preserving FCFS as the basis, we maintain EASY's appeal and enjoy
         both worlds: a fair scheduler that nevertheless backfills
         effectively.
     
     <br/><br/>
     
         Finally, our <b>fourth</b> contribution has broader
         applicability, that transcends the supercomputing domain.  All of
         the above results are based on the standard methodology of
         modeling and simulating real activity logs of production systems,
         which is routinely practiced in system-related research.  The
         overwhelmingly accepted assumption underlying this methodology is
         that such real workloads are representative and reliable.  We
         show, however, that real workloads may also contain anomalies that
         make them non-representative and unreliable.  This is a special
         case of multi-class workloads, where one class is the “real”
         workload which we wish to use in the evaluation, and the other
         class contaminates the log with “bogus” data.  We provide
         several examples of this situation, including an anomaly we call
         “workload flurries”: surges of activity with a repetitive
         nature, caused by a single user, that dominate the workload for a
         relatively short period.  Using a workload with such anomalies in
         effect emphasizes rare and unique events (e.g. occurring for a
         few days out of two years of logged data), and risks optimizing
         the design decision for the anomalous workload at the expense of
         the normal workload.  Thus, we claim that such anomalies should be
         removed from the workload before it is used in evaluations, and
         that ignoring them is actually an unjustifiable approach.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="phd_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @PhdThesis{tsafrir06-phd,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Modeling, evaluating, and improving the performance of
         supercomputer scheduling},</td>
</tr>
<tr>
<td align="right" valign="top">school</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {School of Computer Science and
         Engineering, the Hebrew University (PhD Thesis)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2006,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {September},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Jerusalem, Israel},</td>
</tr>
<tr>
<td align="right" valign="top">note</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Technical Report 2006-78}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ predalg ============ -->
<li>
<!-- anchor -->
<a name="predalg"></a>
<span class="docTitle">
     Session-based, estimation-less, and information-less
         runtime prediction algorithms for parallel and grid job
         scheduling
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     David Talby, Dan Tsafrir, Zviki Goldberg, Dror
         G. Feitelson
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">Technical Report</span> 2006-77, School of Computer Science and
         Engineering, the Hebrew University
     </span>
<br/>
<!-- details -->
     August,
     2006,
     Jerusalem, Israel
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('predalg_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('predalg_bibtex');">BibTeX</a> , 
     <a href="papers/PredAlg05TR.1.pdf">PDF</a> , 
     <a href="http://leibniz.cs.huji.ac.il/anon?View=1&amp;num=1&amp;pid[1]=928&amp;abstract=1">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="predalg_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     The default setting of most production parallel job schedulers is
         FCFS with backfilling. Under this setting, users must supply job
         runtime estimates, which are known as being highly inaccurate and
         inferior to system generated predictions. Recent research revealed
         how to utilize system predictions for backfilling, and this
         potential performance gain motivates searching for better
         prediction techniques.  We present three prediction techniques
         using decreasing levels of information as is suitable for the
         situation at hand. The first is based on "user sessions":
         continuous temporal periods of per-user work. This algorithm
         exploits the entire long-term historical data of the workload,
         along with user runtime estimates.  The second is
         "estimation-less", that is, uses historical data only, relieving
         users from the annoying need to supply estimates. The third is
         completely "informationless" and is suitable for cases in which
         neither historical information nor estimates are available, as
         happens in some grid environments. We evaluate the algorithms by
         simulating real data from production systems. We find all of them
         to be successful in terms of both accuracy and performance.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="predalg_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @TechReport{talby06-predalg,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {David Talby and Dan Tsafrir and Zviki Goldberg and Dror
         G. Feitelson},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Session-based, estimation-less, and information-less
         runtime prediction algorithms for parallel and grid job
         scheduling},</td>
</tr>
<tr>
<td align="right" valign="top">institution</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {School of Computer Science and
         Engineering, the Hebrew University},</td>
</tr>
<tr>
<td align="right" valign="top">number</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {2006-77},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2006,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {August},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Jerusalem, Israel}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ bfly ============ -->
<li>
<!-- anchor -->
<a name="bfly"></a>
<span class="docTitle">
     Instability in parallel job scheduling simulation: the role
         of workload flurries
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir, Dror G. Feitelson
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">IPDPS '06</span>: IEEE International Parallel and Distributed Processing
         Symposium
     </span>
<br/>
<!-- details -->
     April,
     2006,
     Rhodes Island, Greece,
     page 10
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('bfly_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('bfly_bibtex');">BibTeX</a> , 
     <a href="papers/Instability06IPDPS.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1109/IPDPS.2006.1639311">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="bfly_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     The performance of computer systems depends, among other things,
         on the workload.  This motivates the use of real workloads (as
         recorded in activity logs) to drive simulations of new designs.
         Unfortunately, real workloads may contain various anomalies that
         contaminate the data.  A previously unrecognized type of anomaly
         is workload flurries: rare surges of activity with a repetitive
         nature, caused by a single user, that dominate the workload for a
         relatively short period.  We find that long workloads often
         include at least one such event.  We show that in the context of
         parallel job scheduling these events can have a significant effect
         on performance evaluation results, e.g. a very small perturbation
         of the simulation conditions might lead to a large and
         disproportional change in the outcome.  This instability is due to
         jobs in the flurry being effected in unison, a consequence of the
         flurry's repetitive nature.  We therefore advocate that flurries
         be filtered out before the workload is used, in order to achieve
         stable and more reliable evaluation results (analogously to the
         removal of outliers in statistical analysis).  At the same time,
         we note that more research is needed on the possible effects of
         flurries.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="bfly_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{tsafrir06-bfly,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir and Dror G. Feitelson},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Instability in parallel job scheduling simulation: the role
         of workload flurries},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {IEEE International Parallel and Distributed Processing
         Symposium (IPDPS)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2006,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {April},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       10,</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Rhodes Island, Greece}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ clean ============ -->
<li>
<!-- anchor -->
<a name="clean"></a>
<span class="docTitle">
     Workload sanitation for performance evaluation
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dror G. Feitelson, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">ISPASS '06</span>: IEEE International Symposium on Performance Analysis of
         Systems and Software
     </span>
<br/>
<!-- details -->
     March,
     2006,
     Austin, Texas,
     pages 221–230
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('clean_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('clean_bibtex');">BibTeX</a> , 
     <a href="papers/Sanitize06ISPASS.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1109/ISPASS.2006.1620806">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="clean_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     The performance of computer systems depends, among other things,
         on the workload. Performance evaluations are therefore often done
         using logs of workloads on current productions systems, under the
         assumption that such real workloads are representative and
         reliable; likewise, workload modeling is typically based on real
         workloads. We show, however, that real workloads may also contain
         anomalies that make them non-representative and unreliable. This
         is a special case of multi-class workloads, where one class is the
         “real” workload which we wish to use in the evaluation, and the
         other class contaminates the log with “bogus” data. We provide
         several examples of this situation, including a previously
         unrecognized type of anomaly we call “workload flurries”: surges
         of activity with a repetitive nature, caused by a single user,
         that dominate the workload for a relatively short period. Using a
         workload with such anomalies in effect emphasizes rare and unique
         events (e.g.  occurring for a few days out of two years of logged
         data), and risks optimizing the design decision for the anomalous
         workload at the expense of the normal workload. Thus we claim that
         such anomalies should be removed from the workload before it is
         used in evaluations, and that ignoring them is actually an
         unjustifiable approach.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="clean_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{feitelson06-clean,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dror G. Feitelson and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Workload sanitation for performance evaluation},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {IEEE International Symposium on Performance Analysis of
         Systems and Software (ISPASS)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2006,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {March},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {221--230},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Austin, Texas}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ predpat ============ -->
<li>
<!-- anchor -->
<a name="predpat"></a>
<span class="docTitle">
     System and method for backfilling with system-generated
       predictions rather than user runtime estimates
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir, Yoav Etsion, David Talby, Dror G. Feitelson
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">Patent</span> Number: US 8261283 B2 (granted: Sep 2012)
     </span>
<br/>
<!-- details -->
     February,
     2006
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('predpat_bibtex');">BibTeX</a> , 
     <a href="https://www.google.com/patents/US8261283">Html</a>
<br/>
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="predpat_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @Misc{tsafrir06-predpat,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir and Yoav Etsion and David Talby and Dror G. Feitelson},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {System and method for backfilling with system-generated
       predictions rather than user runtime estimates},</td>
</tr>
<tr>
<td align="right" valign="top">howpublished</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Patent Number: US 8261283 B2 (granted: Sep 2012)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2006,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {February}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
</ul>
<!-- ==================== 2005 ==================== -->
<!-- ==================== 2005 ==================== -->
<!-- ==================== 2005 ==================== -->
<h3>2005</h3>
<ul>
<!-- ============ noise ============ -->
<li>
<!-- anchor -->
<a name="noise"></a>
<span class="docTitle">
     System noise, OS clock ticks, and fine-grained parallel
         applications
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir, Yoav Etsion, Dror G. Feitelson, Scott
         Kirkpatrick
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">ICS '05</span>: ACM International Conference on Supercomputing
     </span>
<br/>
<!-- details -->
     June,
     2005,
     Cambridge, Massachusetts,
     pages 303–312
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('noise_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('noise_bibtex');">BibTeX</a> , 
     <a href="papers/Noise05ICS.pdf">PDF</a> , 
     <a href="http://doi.acm.org/10.1145/1088149.1088190">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="noise_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     As parallel jobs get bigger in size and finer in granularity,
         “system noise” is increasingly becoming a problem.  In fact,
         fine-grained jobs on clusters with thousands of SMP nodes run
         faster if a processor is intentionally left idle (per node), thus
         enabling a separation of “system noise” from the computation.
         Paying a cost in average processing speed at a node for the sake
         of eliminating occasional processes delays is (unfortunately)
         beneficial, as such delays are enormously magnified when one late
         process holds up thousands of peers with which it synchronizes.
     
     <br/><br/>
     
         We provide a probabilistic argument showing that, under certain
         conditions, the effect of such noise is linearly proportional to
         the size of the cluster (as is often empirically observed).  We
         then identify a major source of noise to be indirect overhead of
         periodic OS clock interrupts (“ticks”), that are used by all
         general-purpose OSs as a means of maintaining control.  This is
         shown for various grain sizes, platforms, tick frequencies, and
         OSs.  To eliminate such noise, we suggest replacing ticks with an
         alternative mechanism we call “smart timers”.  This turns out to
         also be in line with needs of desktop and mobile computing,
         increasing the chances of the suggested change to be accepted.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="noise_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{tsafrir05-noise,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir and Yoav Etsion and Dror G. Feitelson and Scott
         Kirkpatrick},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {System noise, {OS} clock ticks, and fine-grained parallel
         applications},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM International Conference on Supercomputing
         (ICS)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2005,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {June},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {303--312},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Cambridge, Massachusetts}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ est ============ -->
<li>
<!-- anchor -->
<a name="est"></a>
<span class="docTitle">
     Modeling user runtime estimates
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir, Yoav Etsion, Dror G. Feitelson
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">JSSPP '05</span>: Workshop on Job Scheduling Strategies for Parallel
         Processing
     </span>
<br/>
<!-- details -->
     June,
     2005,
     Cambridge, Massachusetts,
     pages 1–35,
     Lecture Notes in Computer Science, Volume 3834
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('est_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('est_bibtex');">BibTeX</a> , 
     <a href="papers/Est05JSSPP.pdf">PDF</a> , 
     <a href="http://dx.doi.org/10.1007/11605300_1">Definitive</a> , 
     <a href="http://www.cs.huji.ac.il/labs/parallel/workload/m_tsafrir05/">Software</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="est_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     User estimates of job runtimes have emerged as an important
         component of the workload on parallel machines, and can have a
         significant impact on how a scheduler treats different jobs, and
         thus on overall performance.  It is therefore highly desirable to
         have a good model of the relationship between parallel jobs and
         their associated estimates.  We construct such a model based on a
         detailed analysis of several workload traces.  The model
         incorporates those features that are consistent in all of the
         logs, most notably the inherently modal nature of estimates (e.g.\
         only 20 different values are used as estimates for about 90% of
         the jobs).  We find that the behavior of users, as manifested
         through the estimate distributions, is remarkably similar across
         the different workload traces.  Indeed, providing our model with
         only the maximal allowed estimate value, along with the percentage
         of jobs that have used it, yields results that are very similar to
         the original.  The remaining difference (if any) is largely
         eliminated by providing information on one or two additional
         popular estimates.  Consequently, in comparison to previous
         models, simulations that utilize our model are better in
         reproducing scheduling behavior similar to that observed when
         using real estimates.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="est_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InCollection{tsafrir05-est,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir and Yoav Etsion and Dror G. Feitelson},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Modeling user runtime estimates},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Workshop on Job Scheduling Strategies for Parallel
         Processing (JSSPP)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2005,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {June},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {1--35},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Cambridge, Massachusetts},</td>
</tr>
<tr>
<td align="right" valign="top">note</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Lecture Notes in Computer Science, Volume 3834}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ survey ============ -->
<li>
<!-- anchor -->
<a name="survey"></a>
<span class="docTitle">
     A short survey of commercial cluster batch schedulers
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Yoav Etsion, Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">Technical Report</span> 2005-13, School of Computer Science and
         Engineering, the Hebrew University
     </span>
<br/>
<!-- details -->
     May,
     2005,
     Jerusalem, Israel
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('survey_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('survey_bibtex');">BibTeX</a> , 
     <a href="papers/ParSchedSurvey05TR.pdf">PDF</a> , 
     <a href="http://leibniz.cs.huji.ac.il/anon?View=1&amp;num=1&amp;pid[1]=742&amp;abstract=1">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="survey_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     As high performance computing clusters are getting cheaper, they
         become more accessible. The various clusters are running a host of
         workload management software suites, which are getting more
         complex and offer cluster administrators numerous features,
         scheduling policies, job prioritization schemes, etc.  In this
         paper we survey some of the common commercial workload managers on
         the market, covering their main features — specifically the
         scheduling policies and algorithms they support, their priority
         and queueing mechanisms, focusing on their default settings.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="survey_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @TechReport{etsion05-survey,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Yoav Etsion and Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {A short survey of commercial cluster batch schedulers},</td>
</tr>
<tr>
<td align="right" valign="top">institution</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {School of Computer Science and
         Engineering, the Hebrew University},</td>
</tr>
<tr>
<td align="right" valign="top">number</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {2005-13},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2005,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {May},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Jerusalem, Israel}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ timing ============ -->
<li>
<!-- anchor -->
<a name="timing"></a>
<span class="docTitle">
     General purpose timing: the failure of periodic timers
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir, Yoav Etsion, Dror G. Feitelson
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">Technical Report</span> 2005-6, School of Computer Science and
         Engineering, the Hebrew University
     </span>
<br/>
<!-- details -->
     February,
     2005,
     Jerusalem, Israel
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('timing_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('timing_bibtex');">BibTeX</a> , 
     <a href="papers/Timing05TR.pdf">PDF</a> , 
     <a href="http://leibniz.cs.huji.ac.il/anon?View=1&amp;num=1&amp;pid[1]=734&amp;abstract=1">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="timing_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     All general-purpose commodity operating systems use periodic clock
         interrupts to regain control and measure the passage of time. This
         is ill-suited for desktop settings, as the ne-grained timing
         requirements of modern multimedia applications require a high
         clock rate, which may suffer from significant overhead. It is
         ill-suited for HPC environments, as asynchronous interrupts ruin
         the coordination among cluster nodes. And it is ill-suited for
         mobile platforms, as it wastes signicant energy, especially when
         the system is otherwise idle. To be truly general-purpose, systems
         should therefore switch to a mechanism that is closer to one-shot
         timers (set only for specic needs) while avoiding the potentially
         huge overhead they entail. With a careful design it is possible to
         achieve both high accuracy and low overhead, thus signicantly
         extending the applicability of general-purpose operating systems.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="timing_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @TechReport{tsafrir05-timing,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir and Yoav Etsion and Dror G. Feitelson},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {General purpose timing: the failure of periodic timers},</td>
</tr>
<tr>
<td align="right" valign="top">institution</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {School of Computer Science and
         Engineering, the Hebrew University},</td>
</tr>
<tr>
<td align="right" valign="top">number</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {2005-6},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2005,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {February},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Jerusalem, Israel}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
</ul>
<!-- ==================== 2004 ==================== -->
<!-- ==================== 2004 ==================== -->
<!-- ==================== 2004 ==================== -->
<h3>2004</h3>
<ul>
<!-- ============ huc-pri ============ -->
<li>
<!-- anchor -->
<a name="huc-pri"></a>
<span class="docTitle">
     Desktop scheduling: how can we know what the user wants?
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Yoav Etsion, Dan Tsafrir, Dror G. Feitelson
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">NOSSDAV '04</span>: ACM International Workshop on Network and Operating Systems
         Support for Digital Audio and Video
     </span>
<br/>
<!-- details -->
     June,
     2004,
     Kinsale, Ireland,
     pages 110–115
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('huc-pri_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('huc-pri_bibtex');">BibTeX</a> , 
     <a href="papers/HuCpri04NOSSDAV.pdf">PDF</a> , 
     <a href="http://doi.acm.org/10.1145/1005847.1005872">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="huc-pri_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Current desktop operating systems use CPU utilization (or lack
         thereof) to prioritize processes for scheduling. This was thought
         to be beneficial for interactive processes, under the assumption
         that they spend much of their time waiting for user input. This
         reasoning fails for modern multimedia applications. For example,
         playing a movie in parallel with a heavy background job usually
         leads to poor graphical results, as these jobs are
         indistinguishable in terms of CPU usage. Suggested solutions
         involve shifting the burden to the user or programmer, which we
         claim is unsatisfactory; instead, we seek an automatic
         solution. Our attempts using new metrics based on CPU usage
         failed. We therefore propose and implement a novel scheme of
         identifying interactive and multimedia applications by directly
         quantifying the I/O between an application and the user (keyboard,
         mouse, and screen activity). Preliminary results indicate that
         prioritizing processes according to this metric indeed solves the
         aforementioned problem, demonstrating that operating systems can
         indeed provide better support for multimedia and interactive
         applications. Additionally, once user I/O data is available, it
         opens intriguing new possibilities to system designers.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="huc-pri_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{etsion04-huc-pri,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Yoav Etsion and Dan Tsafrir and Dror G. Feitelson},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Desktop scheduling: how can we know what the user wants?},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM International Workshop on Network and Operating Systems
         Support for Digital Audio and Video (NOSSDAV)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2004,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {June},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {110--115},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Kinsale, Ireland}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
</ul>
<!-- ==================== 2003 ==================== -->
<!-- ==================== 2003 ==================== -->
<!-- ==================== 2003 ==================== -->
<h3>2003</h3>
<ul>
<!-- ============ flurry ============ -->
<li>
<!-- anchor -->
<a name="flurry"></a>
<span class="docTitle">
     Workload flurries
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir, Dror G. Feitelson
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">Technical Report</span> 2003-85, School of Computer Science and
         Engineering, the Hebrew University
     </span>
<br/>
<!-- details -->
     November,
     2003,
     Jerusalem, Israel
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('flurry_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('flurry_bibtex');">BibTeX</a> , 
     <a href="papers/Flurry03TR.pdf">PDF</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="flurry_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     The performance of computer systems depends, among other things,
         on the workload. Performance evaluations are therefore often done
         using logs of workloads on current productions systems, under the
         assumption that such real workloads are representative and
         reliable; likewise, workload modeling is typically based on real
         workloads. However, real workloads may also contain anomalies that
         make them non-representative and unreliable. A previously
         unrecognized type of anomaly is workload urries: surges of
         activity with a repetitive nature, caused by a single user, that
         dominate the workload for a relatively short period. Under
         suitable conditions, such urries can have a decisive effect on
         performance evaluation results. The problem is that workloads
         containing such a urry are not representative of normal
         usage. Moreover, creating a statistical model based on such a
         workload or using it directly is also not representative of urries
         in general. This motivates the approach of identifying and
         removing the urries, so as to allow for an evaluation under normal
         conditions. We demonstrate this for several evaluations of
         parallel systems, showing that the anomalies in the workload as
         embodied by urries carry over to anomalies in the evaluation
         results, which disappear when the urries are removed. Such an
         evaluation can then be augmented by a separate evaluation of the
         deviation caused by the urry.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="flurry_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @TechReport{tsafrir03-flurry,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir and Dror G. Feitelson},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Workload flurries},</td>
</tr>
<tr>
<td align="right" valign="top">institution</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {School of Computer Science and
         Engineering, the Hebrew University},</td>
</tr>
<tr>
<td align="right" valign="top">number</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {2003-85},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2003,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {November},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Jerusalem, Israel}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
<!-- ============ clock ============ -->
<li>
<!-- anchor -->
<a name="clock"></a>
<span class="docTitle">
     Effects of clock resolution on the scheduling of
         interactive and soft real-time processes
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Yoav Etsion, Dan Tsafrir, Dror G. Feitelson
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">SIGMETRICS '03</span>: ACM SIGMETRICS International Conference on Measurement and
         Modeling
     </span>
<br/>
<!-- details -->
     June,
     2003,
     San Diego, California,
     pages 172–183
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('clock_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('clock_bibtex');">BibTeX</a> , 
     <a href="papers/ClockRes03SIGMETRICS.pdf">PDF</a> , 
     <a href="http://doi.acm.org/10.1145/781027.781049">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="clock_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     It is commonly agreed that scheduling mechanisms in general
         purpose operating systems do not provide adequate support for
         modern interactive applications, notably multimedia
         applications. The common solution to this problem is to devise
         specialized scheduling mechanisms that take the specific needs of
         such applications into account. A much simpler alternative is to
         better tune existing systems. In particular, we show that
         conventional scheduling algorithms typically only have little and
         possibly misleading information regarding the CPU usage of
         processes, because increasing CPU rates have caused the common 100
         Hz clock interrupt rate to be coarser than most application time
         quanta. We therefore conduct an experimental analysis of what
         happens if this rate is significantly increased. Results indicate
         that much higher clock interrupt rates are possible with
         acceptable overheads, and lead to much better information. In
         addition we show that increasing the clock rate can provide a
         measure of support for soft real time requirements, even when
         using a general-purpose operating system. For example, we achieve
         a sub-millisecond latency under heavily loaded conditions.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="clock_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{etsion03-clock,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Yoav Etsion and Dan Tsafrir and Dror G. Feitelson},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Effects of clock resolution on the scheduling of
         interactive and soft real-time processes},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {ACM SIGMETRICS International Conference on Measurement and
         Modeling (SIGMETRICS)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2003,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {June},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {172--183},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {San Diego, California}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
</ul>
<!-- ==================== 2002 ==================== -->
<!-- ==================== 2002 ==================== -->
<!-- ==================== 2002 ==================== -->
<h3>2002</h3>
<ul>
<!-- ============ sync ============ -->
<li>
<!-- anchor -->
<a name="sync"></a>
<span class="docTitle">
     Barrier synchronization on a loaded SMP using two-phase
         waiting algorithms
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir, Dror G. Feitelson
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">IPDPS '02</span>: IEEE International Parallel and Distributed Processing
         Symposium
     </span>
<br/>
<!-- details -->
     April,
     2002,
     Fort Lauderdale, Florida,
     page 80
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('sync_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('sync_bibtex');">BibTeX</a> , 
     <a href="papers/Barrier02IPDPS.pdf">PDF</a> , 
     <a href="http://doi.ieeecomputersociety.org/10.1109/IPDPS.2002.1015592">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="sync_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Little work has been done on the performance of barrier
         synchronization using two-phase blocking, as the common wisdom is
         that it is useless to spin if the total number of threads in the
         system exceeds the number of processors. We challenge this and
         show that it may be beneficial to spin-wait even if the number of
         threads is up to double the number of processors, especially if
         the waiting time is at least twice the context switch overhead
         (rather than being equal to it). We also characterize the
         alternating synchronization pattern that applications based on
         barriers tend to fall into, which is quite different from the
         patterns typically assumed in theoretical analyses.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="sync_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @InProceedings{tsafrir02-sync,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir and Dror G. Feitelson},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Barrier synchronization on a loaded {SMP} using two-phase
         waiting algorithms},</td>
</tr>
<tr>
<td align="right" valign="top">booktitle</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {IEEE International Parallel and Distributed Processing
         Symposium (IPDPS)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2002,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {April},</td>
</tr>
<tr>
<td align="right" valign="top">pages</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       80,</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Fort Lauderdale, Florida}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
</ul>
<!-- ==================== 2001 ==================== -->
<!-- ==================== 2001 ==================== -->
<!-- ==================== 2001 ==================== -->
<h3>2001</h3>
<ul>
<!-- ============ msc ============ -->
<li>
<!-- anchor -->
<a name="msc"></a>
<span class="docTitle">
     Barrier synchronization on a loaded SMP using two-phase
         waiting algorithms
     </span>
<br/>
<!-- author -->
<span class="docAuthors">
     Dan Tsafrir
     </span>
<br/>
<!-- venue -->
<span class="docVenue">
<span class="docVenueAbrv">MSc</span>: Technical Report 2001-82, School of Computer Science and
         Engineering, the Hebrew University
     </span>
<br/>
<!-- details -->
     September,
     2001,
     Jerusalem, Israel
     <br/>
<!-- availabilities -->
<a href="javascript:toggleblocks('msc_abstract');">Abstract</a> , 
     <a href="javascript:toggleblocks('msc_bibtex');">BibTeX</a> , 
     <a href="papers/MscThesis.pdf">PDF</a> , 
     <a href="http://leibniz.cs.huji.ac.il/anon?View=1&amp;num=1&amp;pid[1]=1205&amp;abstract=1">Definitive</a>
<br/>
<!-- abstract (collapse/expend) -->
<div class="collapseblock" id="msc_abstract" style="border:1px dotted gray;padding:20px;width:600px">
 
     Little work has been done on the performance of barrier
           synchronization using two-phase blocking, as the common wisdom is that
           it is useless to spin if the total number of threads in the system 
           exceeds the number of processors. 
           We challenge this view and show that it may be beneficial to spin-wait
           if the spinning period is set to be a bit more than twice the context
           switch overhead (rather than being equal to it).
           We show that the success of our approach is due to an inherent
           property of general-purpose schedulers, which tend to select
           threads that become unblocked for immediate execution.
           We find that this property causes applications based on barriers to
           fall into a previously unnoticed pattern, denoted “alternating
           synchronization”, which is quite different from the patterns
           typically assumed in theoretical analyses. 
           By merely choosing an appropriate spinning period, we leverage
           alternating synchronization to implicitly nudge the system
           into simultaneously co-scheduling the application's threads, thereby
           dramatically reducing the overhead of synchronization and
           significantly improving the performance.
 
     </div> <!-- of collapse/expend -->
<!-- bibtex (collapse/expend) -->
<div class="collapseblock" id="msc_bibtex" style="border:1px dotted gray;padding:20px;width:600px">
 
     @MastersThesis{tsafrir01-msc,
     
     <div>
<table class="myBib">
<tr>
<td align="right" valign="top">author</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Dan Tsafrir},</td>
</tr>
<tr>
<td align="right" valign="top">title</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Barrier synchronization on a loaded {SMP} using two-phase
         waiting algorithms},</td>
</tr>
<tr>
<td align="right" valign="top">school</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {School of Computer Science and
         Engineering, the Hebrew University (MSc Thesis)},</td>
</tr>
<tr>
<td align="right" valign="top">year</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       2001,</td>
</tr>
<tr>
<td align="right" valign="top">month</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {September},</td>
</tr>
<tr>
<td align="right" valign="top">address</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Jerusalem, Israel},</td>
</tr>
<tr>
<td align="right" valign="top">note</td>
<td align="right" valign="top">=</td>
<td align="left" valign="top">
       {Technical Report 2001-82}</td>
</tr>
</table>
</div> <!-- bibtex -->
     }
 
     </div> <!-- of collapse/expend -->
<p>
</p></li>
</ul>
<!-- ==== END OF BODY ==== -->
</td>
</tr>
</table>
</td>
</tr>
<!-- ==================== 4th line (hr) ====================== -->
<!--  <tr><td><hr></td></tr> -->
</table>
</body>